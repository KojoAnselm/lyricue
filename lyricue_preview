#!/usr/bin/env perl

#****** lyricue_preview/pod
# NAME
#   Pod documentation
# DESCRIPTION
#   Documentation for lyricue that is displayed by perldoc
# SOURCE
#

=head1 NAME

lyricue_preview

=head1 SYNOPSIS

lyricue_preview [ C<-d[q]> C<-s> I<server> ]

=head1 DESCRIPTION

=head1 OPTIONS

=over 4

=item B<-d>

Turn on debugging mode. Prints out debugging information

=item B<-s>

Set server to connect to for Db and screen

=head1 CONFIGURATION

All configuration is done by editing the configuration section in the program

=head1 REQUIRES

Perl 5.6 or later, Gtk2-Perl, MySql database

=head1 AUTHOR

Chris Debenham <chris@adebenham.com>

=head1 COPYRIGHT

This program is released under the GPL (http://www.gnu.org/copyleft/gpl.html)

=head1 VERSION

Lyricue_preview Version 0.1

=cut

#***

#****** lyricue/setup
# NAME
#   Setup section
# DESCRIPTION
#   Loads required modules, sets some global variables,
#   and other global things
# SOURCE
#

#
# Modules we use.
#
use strict;
use warnings;
use POSIX;
use IO::Socket::INET;
use Encode;
die "The gtk2-perl bindings could not be initialized; we need them to run!\n"
  unless (Gtk2->init_check);
use Gtk2;
eval { require Locale::gettext };
if ($@) {
    print "Gettext not available, english text only\n";

    sub gettext {
        return $@;
    }
} else {
    import Locale::gettext;
    textdomain('lyricue');

    # Hack to get this working under mandrake
    use lib qw(/usr/lib/libDrakX);
    eval { require c::stuff };
    if ($@) {
        bind_textdomain_codeset('lyricue', "UTF-8");
    } else {
        c::stuff::bind_textdomain_codeset('lyricue', "UTF-8");
    }
}
binmode(STDOUT, ":utf8");
binmode(STDERR, ":utf8");


#
# Site Configuration.  You should only have to
# edit this section.
#
my ($globals);

#
# You shouldn't have to change anything after this line
#

# convenience variables for true and false
use constant FALSE => 0;
use constant TRUE  => 1;

$globals->{'version'}     = "0.1";
$globals->{'host'}        = "localhost";
$globals->{'timer'}            = FALSE;
$globals->{'debugging'}        = FALSE;
$globals->{'server_port'}      = "2346";    #port used for lyric server

#***

#****** lyricue/main_code
# NAME
#   main_code - main code section, not in subroutine
# SYNOPSIS
#   No output
# FUNCTION
#   Figure out where to go
# INPUTS
#   Commandline
# OUTPUT
#   Everything
# SOURCE
#
if ($ARGV[0]) {
    foreach (0 .. (@ARGV - 1)) {
        if ($ARGV[$_] eq "-v") {
            print "Lyric Interface version " . $globals->{'version'} . "\n";
            exit;
        } elsif ($ARGV[$_] eq "-d") {
            $globals->{'debugging'} = 1;
        } elsif ($ARGV[$_] eq "-s") {
            $globals->{'host'} = $ARGV[$_ + 1];
            $ARGV[$_ + 1] = "";
        } elsif ($ARGV[$_] eq "-p") {
            $globals->{'server_port'} = $ARGV[$_ + 1];
            $ARGV[$_ + 1] = "";
        } elsif ($ARGV[$_] eq "-m") {
            $globals->{'plugid'} = $ARGV[$_ + 1];
            if (!$globals->{'plugid'} =~ /\d+$/) {
                $globals->{'plugid'} = 0;
            }
            $ARGV[$_ + 1] = "";
        } elsif ($ARGV[$_] eq "") {
            # ignore
        } else {
            print "\nUsage: lyricue <-v|-l> <-b> <-k> <-d[q]> <-s>\n\n";
            print "\t-v:  Prints Lyricue version information & exits\n";
            print "\t-d:  Prints debugging messages\n";
            exit;
        }
    }
}

# Set umask
umask 0002;

$globals->{'timer'} = Glib::Timeout->add (5000, \&update_display);
debug ("Plugid=".$globals->{'plugid'});
$globals->{'window'} = Gtk2::Plug->new($globals->{'plugid'});
$globals->{'window'}->set_title("Lyricue Preview");
$globals->{'window'}->resize(200,150);
$globals->{'image'}= Gtk2::Image->new;
$globals->{'image'}->set_size_request(200, 150);
$globals->{'window'}->add($globals->{'image'});
$globals->{'window'}->show_all();


update_display();

Gtk2->main();

# Should never get here
exit(0);

#***

#****m* lyricue/close_main
# NAME
#   close_main -- close the main window
# SYNOPSIS
#   close_main ()
# FUNCTION
#   Callback function to close the window
# INPUTS
#   none
# OUTPUT
#   Closes the interface
# SOURCE
sub close_main {
    debug("Quitting");
    do_pending();
    Gtk2->main_quit;
    exit();
    return FALSE;
}

#***

#****m* lyricue/update_display
# NAME
#   update_display --
# SYNOPSIS
#   update_display ($command, $primary, $secondary)
# FUNCTION
#   Open a connection the the server and send a command. Status is returned
# INPUTS
#   $command - Command to send
#   $primary - First parameter to send
#   $secondary - Second parameter to send
# OUTPUT
#   Updated display
# SOURCE
#
sub update_display {
    debug("update display");
    if (
        my $server = IO::Socket::INET->new(
            Proto    => "tcp",
            PeerAddr => $globals->{'host'},
            PeerPort => $globals->{'server_port'}
        )
      )
    {
        print $server Encode::encode("utf-8",
            "snapshot::\n");
        if (defined(my $status = <$server>)) {
                if ($status ne "\n") {
                    debug("Loading snapshot");
                    my $linein = $status;
                    while ($linein ne "ENDRESPONSE") {
                        $linein = <$server>;
                        $status .= $linein;
                        chomp($linein);
                        do_pending();
                    }
                    debug("Got Snapshot");
                    my $pixbuf_loader = Gtk2::Gdk::PixbufLoader->new();
                    eval { $pixbuf_loader->write($status); };
                    eval { $pixbuf_loader->close() };
                    my $pixbuf = $pixbuf_loader->get_pixbuf();
                    $globals->{'image'}->set_from_pixbuf($pixbuf);
                    debug("Loaded image");
                }
        }
        close($server);
    }
    return TRUE;
}

sub do_pending {
    while (Gtk2->events_pending) {
     Gtk2->main_iteration;
    }
}

sub debug {
    if ($globals->{'debugging'}) {
        my $text = shift;
        chomp($text);
        if ($text) {
            my ($sec,$min,$hour,undef) = localtime(time);
            print STDERR $hour.":".$min.":".$sec."|PREVIEW: ";
            print STDERR $text . "\n";
        }
    }
    return TRUE;
}

