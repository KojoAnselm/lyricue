#!/usr/bin/env perl
my $ID = q$Id: lyricue_server,v 1.169 2009/05/24 07:43:35 cjdebenh Exp $;

#****** lyricue_server/pod
# NAME
#   Pod documentation
# DESCRIPTION
#   Documentation for lyricue_server that is displayed by perldoc
# SOURCE
#

=head1 NAME

lyricue_server - Lyricue Server

=head1 SYNOPSIS

lyricue_server [ C<-v|-b> C<-m> C<-d> ]

=head1 DESCRIPTION

This script creates a fullscreen window that is used to display song lyrics (normally on a second screen, projector or similar) OR a scaled server window that can be used to preview songs a given screen.

=head1 OPTIONS

=over 4

=item B<-v>

Get lyricue_server version

=item B<-d>

Turn on debugging mode. Prints out debugging information

=item B<-m>

Run in miniserv mode (used for preview window in interface)


=head1 CONFIGURATION

All configuration is done by editing the configuration section in the program

=head1 REQUIRES

Perl 5.6 or later, DBI::MySQL, Gtk2-Perl, MySql database

=head1 AUTHOR

Chris Debenham <chris@adebenham.com>

=head1 COPYRIGHT

This program is released under the GPL (http://www.gnu.org/copyleft/gpl.html)

=head1 VERSION

Lyricue_server Version 1.9.9

=cut

#***

#****** lyricue_server/setup
# NAME
#   Setup section
# DESCRIPTION
#   Loads required modules, sets some global variables,
#   and other global things
# SOURCE
#

#
# Modules we use.
#
use strict;
use DBI;
use POSIX;
use IO::Socket::INET;    #use Socket;
use Encode;
die "The gtk2-perl bindings could not be initialized; we need them to run!\n"
  unless (Gtk2->init_check);
use Gtk2::Pango;
use Gtk2::GladeXML;
use Gtk2::Gdk::Keysyms;
use Glib;

eval { require Locale::gettext };

if ($@) {
    print "Gettext not available, english text only\n";

    sub gettext {
        return $@;
    }
} else {
    import Locale::gettext;
    textdomain('lyricue');

    # Hack to get this working under mandrake
    use lib qw(/usr/lib/libDrakX);
    eval { require c::stuff };
    if ($@) {
        bind_textdomain_codeset('lyricue', "UTF-8");
    } else {
        c::stuff::bind_textdomain_codeset('lyricue', "UTF-8");
    }
}
binmode(STDOUT, ":utf8");
binmode(STDERR, ":utf8");

# convenience variables for true and false
use constant FALSE => 0;
use constant TRUE  => 1;

# Transition types
use constant NORMAL     => 0;
use constant SLIDE_TEXT => 1;
use constant WIPE       => 2;
use constant CLIP       => 3;
use constant ROTATE     => 4;

# Transition directions
use constant NONE      => 2**0;
use constant WAIT      => 2**1;
use constant UP        => 2**2;
use constant DOWN      => 2**3;
use constant RIGHT     => 2**4;
use constant LEFT      => 2**5;
use constant X_AXIS    => 2**6;
use constant Y_AXIS    => 2**7;
use constant Z_AXIS    => 2**8;
use constant NUM_TRANS => 8;

# Server types
use constant CANVAS  => 0;
use constant SIMPLE  => 1;
use constant CLUTTER => 2;

#
# Site Configuration.  You should only have to
# edit this section.
#

my ($globals);
$globals->{'etcdir'}   = "/etc/lyricue/";
$globals->{'basedir'}  = Glib::get_user_data_dir . "/lyricue/";
$globals->{'sharedir'} = "/usr/share/lyricue/";

#
# You shouldn't have to change anything after this line
#

$globals->{'version'}     = "1.9.9";
$globals->{'accessfile'}  = $globals->{'etcdir'} . "access.conf";
$globals->{'defaultconf'} = $globals->{'etcdir'} . "default.conf";
$globals->{'configfile'}  = $globals->{'basedir'} . "config2";
$globals->{'gladefile'}   = $globals->{'sharedir'} . "lyricue.glade";
$globals->{'host'}        = "localhost";
$globals->{'lyricdb'}     = "lyricDb";
$globals->{'mediadb'}     = "mediaDb";
$globals->{'bibledb'}     = "";
$globals->{'biblename'}   = "";
$globals->{'usesword'}    = TRUE;
$globals->{'bg_file'}     = "/tmp/lyricue.bg";
$globals->{'preview'}     = FALSE;
$globals->{'use_port'}      = "2346";    #port used for lyric server socket
$globals->{'server_port'}   = "2346";    #port used for lyric server socket
$globals->{'preview_port'}  = "2347";    #port used for lyric server socket
$globals->{'miniview_port'} = "2348";    #port used for lyric server socket
$globals->{'run_windowed'}  = FALSE;
$globals->{'server_type'}   = CANVAS;
$globals->{'blanked_state'} = TRUE;
$globals->{'bgid'}          = "";
$globals->{'diatheke'} = `which diatheke`;
chomp $globals->{'diatheke'};

if ($globals->{'diatheke'} eq "") {
    $globals->{'diatheke'} = "true";
}

my $DEBUG           = FALSE;
my $exec_pid        = 0;
my $MINISERV        = -1;
my $MINISCALE       = 1;       # Default Scaling
my $LOOPPARENT      = -1;      #Absolute parent for looping in sublists
my $current_list    = 1;
my $current_item    = 1;
my $preview_item    = 0;
my $current_point   = -1;
my $steps           = 20;
my $bgimage_changed = FALSE;
my $headerHeight    = 0;
my ($background, $background_black);
my @points;

my ($errorcodes);
$errorcodes->{'lyricdbopen'} = fromutf(
    gettext(
"I'm sorry but I could not open the lyric database.\nPlease confirm that Lyricue is installed correctly and MySql is running"
    )
);
$errorcodes->{'bibledbopen'} = fromutf(
    gettext(
"I'm sorry but I could not open the bible database.\nPlease confirm that Lyricue is installed correctly and the current bible database exists.\nThe requested database was named "
    )
  ),
  $errorcodes->{'sqlprepare'} =
  fromutf(gettext("Unable to prepare query.\nHas mysql died?"));
$errorcodes->{'sqlexecute'} =
  fromutf(gettext("Unable to execute query.\nHas mysql died?"));
$errorcodes->{'socketopen'} = fromutf(
    gettext(
"Sorry, I was unable to listen on the network.\nPlease make sure I am not already running"
    )
);

#***

#****** lyricue_server/main_code
# NAME
#   main_code - main code section, not in subroutine
# SYNOPSIS
#   No output
# FUNCTION
#   Figure out where to go
# INPUTS
#   Commandline
# OUTPUT
#   Everything
# SOURCE
#

# Parse command line arguments
if ($ARGV[0]) {
    foreach (0 .. (@ARGV - 1)) {
        if ($ARGV[$_] eq "-v") {
            print "Lyricue Server version " . $globals->{'version'} . "\n";
            exit;
        } elsif ($ARGV[$_] eq "-f") {
            $globals->{'server_type'} = SIMPLE;
        } elsif ($ARGV[$_] eq "-c") {
            $globals->{'server_type'} = CLUTTER;
        } elsif ($ARGV[$_] eq "-d") {
            $DEBUG = 1;
            debug("Lyric Server version " . $globals->{'version'} . "\n" . $ID);
        } elsif ($ARGV[$_] eq "-m") {
            $MINISERV = $ARGV[$_ + 1];
            if (!$MINISERV =~ /\d+$/) {
                $MINISERV = 0;
            }
            $ARGV[$_ + 1] = "";
        } elsif ($ARGV[$_] eq "-r") {
            $globals->{'host'} = $ARGV[$_ + 1];
            $ARGV[$_ + 1] = "";
        } elsif ($ARGV[$_] eq "-p") {
            $globals->{'use_port'} = $ARGV[$_ + 1];
            $ARGV[$_ + 1] = "";
        } elsif ($ARGV[$_] eq "-sqlite") {
            $globals->{'force_sqlite'} = TRUE;
        } elsif ($ARGV[$_] eq "-w") {
            $globals->{'run_windowed'} = TRUE;
        } elsif ($ARGV[$_] eq "-geometry") {
            $globals->{'window_offset'} = $ARGV[$_ + 1];
            $ARGV[$_ + 1] = "";
        } elsif (($ARGV[$_] =~ /^\d+$/) || ($ARGV[$_] eq "")) {
        } else {
            print
"\nUsage: lyricue_server <-v> <-m> <-c> <-d> <-r hostname> <-w>\n\n";
            print "\t-v: Prints Lyricue version information & exits\n";
            print "\t-d: Prints debugging messages\n";
            print "\t-r: Remote hostname where sql server is running\n";
            print "\t-m: Runs in miniserv mode (acts as a preview window)\n";
            print "\t-w: Runs in a window (rather than fullscreen\n";
            print "\t-c: Runs with clutter server\n";
            print "\t-f: Runs with simple server\n";
            print "\t-sqlite: Force usage of sqlite\n";
            exit;
        }
    } ## end foreach (0 .. (@ARGV - 1))
} ## end if ($ARGV[0])

# Read the config file
if (!-w $globals->{'configfile'}) {
    if (!-d $globals->{'basedir'}) {
        mkdir $globals->{'basedir'}, 0777;
    }
    system("cp " . $globals->{'defaultconf'} . " " . $globals->{'configfile'});
}
my $config = load_config();
db_check_app();
if ($config->{'ServerType'} eq "simple") {
    $globals->{'server_type'} = SIMPLE;
} elsif ($config->{'ServerType'} eq "clutter") {
    $globals->{'server_type'} = CLUTTER;
}

my ($contents, @preset);
if (!($config->{'Colour'})) {
    $config->{'Colour'} = "#ffffff";
}

my ($bibleDbh);
foreach (keys %$config) {
    if (/^Preset/) {
        my $num = $_;
        $num =~ s/^Preset//g;
        $preset[$num] = $config->{$_};
    } elsif (/^DefBible/) {
        my @tmp  = split(/;/, $config->{$_}, 2);
        my @tmp2 = split(/:/, $tmp[0],       2);
        $globals->{'bibledb'} = $tmp2[0];
        change_to_db($globals->{'bibledb'}, $tmp2[1]);
    }
}

my $pid =
`ps -e -o pid,cmd | grep "Lyricue Server on port $globals->{'use_port'}" | grep -v "grep" |sed -e 's/^ *//g' | cut -f1 -d" " `;
chomp($pid);
if ($pid) {
    debug("Lyricue Server was already running on given port, killing");
    kill 9, $pid;
}

# Open lyricDB and mediaDB
my $lyricDbh = db_connect($globals->{'lyricdb'}, $errorcodes->{'lyricdbopen'});
my $mediaDbh = db_connect($globals->{'mediadb'}, $errorcodes->{'mediadbopen'});

# Set current_page to a valid value
my $query = "SELECT MIN(playorder) FROM playlist";
debug($query);
my $sth = $lyricDbh->prepare($query)
  || display_fatal($errorcodes->{'sqlprepare'}, $!);
my $rv = $sth->execute
  || display_fatal($errorcodes->{'sqlexecute'}, $!);
my @row = $sth->fetchrow_array();
$current_item = $row[0];

# Create/Update tracker field
check_tracker();

# Create the window
debug("Creating window");
create_window();

# init the TCP mode
my ($socket);
my @cnx = ();
my $con = 0;
my ($name, $aliases, $proto) = getprotobyname('tcp');

if ($globals->{'use_port'} !~ /^\d+$/) {
    ($name, $aliases, $globals->{'use_port'}) =
      getservbyport($globals->{'use_port'}, 'tcp');
}

do_pending();

debug("Loading background");
if (!($config->{'BGImage'} =~ /;/)) {
    $config->{'BGImage'} = "db;" . $config->{'BGImage'};
}

change_backdrop($config->{'BGImage'});

my $sockaddr = 'S n a4 x8';
$socket = IO::Socket::INET->new(
    Listen    => SOMAXCONN,
    LocalPort => $globals->{'use_port'},
    Reuse     => 1,
    Proto     => 'tcp'
);
$socket or display_fatal($errorcodes->{'socketopen'}, $!);
$0 = "Lyricue Server on port " . $globals->{'use_port'};
my $h;
use IO::Select;
my $s = IO::Select->new($socket);

debug("Listening on " . $globals->{'use_port'});

# Disable screensaver
system('xset s off -dpms');

debug("Main program running");
Glib::Timeout->add(200, \&check_net);
Gtk2->main();

sub check_net {
    my @ready = $s->can_read(0);
    foreach $h (@ready) {
        check_socket($socket);
    }
    return TRUE;
}

# Should never get here
exit(0);

#***

#****f* lyricue_server/process_input
# NAME
#   process_input
# SYNOPSIS
#   process_input ()
# FUNCTION
#   Reads from the socket and processes whatever is there
# INPUTS
#   text from socket
# OUTPUT
#   Update lyric screen
# SOURCE
#
sub process_input {
    debug("Beginning transaction from socket");
    my ($input) = @_;
    my $status = "";

    debug("Received :" . $input);
    if ($input) {
        fromutf($input);
        chomp($input);
        my @line = split(/:/, $input);
        $_ = lc($line[0]);

        if (/^status$/) {
            $status =
                "Status,W:"
              . $config->{'Width'} . ",H:"
              . $config->{'Height'} . ",F:"
              . $config->{'Main'} . ",B:"
              . $globals->{'bibledb'};
            if ($line[1] eq "previewon") {
                $globals->{'preview'} = TRUE;
            } else {
                $globals->{'preview'} = FALSE;
            }
        } elsif (/^snapshot$/) {
            $status = "";
            if ($globals->{'snapshot_changed'} || ($line[1] eq "force")) {
                open(IMG, "/tmp/lyricue_" . $globals->{'use_port'} . ".png");
                while (<IMG>) {
                    $status .= $_;
                }
                close BGIMG;
                $globals->{'snapshot_changed'} = FALSE;
            }
            $status .= "\nENDRESPONSE";
            debug("Returning image data");
            return $status;
        } elsif (/^reconfig$/) {
            $config = load_config();
            $status = gettext("Configuration reloaded");
        } elsif (/^backdrop$/) {
            $config->{'BGImage'} = $line[1];
            change_backdrop($config->{'BGImage'});
            $status = gettext("Backdrop changed to ") . $config->{'BGImage'};
        } elsif (/^blank$/) {
            set_header("");
            set_footer("");
            set_maintext("", NONE, FALSE);
            if ($line[1] ne "") {
                $config->{'BGImage'} = $line[1];
                change_backdrop($config->{'BGImage'});
                $status = gettext("Screen blanked");
            } else {
                $status = gettext("Text cleared");
            }
            $globals->{'blanked_state'} = TRUE;
        } elsif (/^change_to_db$/) {
            change_to_db($line[1], $line[2]);
            $status = gettext("Bible changed to ") . $globals->{'bibledb'};
        } elsif (/^next_point$/) {
            $globals->{'blanked_state'} = FALSE;
            if ($current_point > -1 && scalar(@points) > $current_point + 1) {
                my $pointtext = "";
                $current_point++;

                #Add all points up and including to current point
                for (my $count = 1 ; $count <= $current_point ; $count++) {
                    $pointtext .= $points[$count];
                }

                #Now figure out how many \n's to add
                if (my @original = ((join "", @points) =~ /\n/g)) {
                    if (my @pt = $pointtext =~ /\n/g) {
                        for (
                            my $ns = 0 ;
                            $ns < scalar(@original) - scalar(@pt) ;
                            $ns++
                          )
                        {
                            $pointtext .= "\n";
                        }
                    }
                }

                $pointtext =~ s/<.*?>//g;
                set_maintext($pointtext, NONE, FALSE);
            } else {
                debug("Can not advance one point - no points waiting");
            }
        } elsif (/^preview$/) {
            my $wrap = FALSE;
            if ($line[1] ne "ignore") {
                $line[1] =~ s/#SEMI#/:/g;
                my @extras = split(/#BREAK#/, $line[1]);
                if ((defined $extras[3]) && ($extras[3] eq "wrap")) {
                    $wrap = TRUE;
                }
                set_header($extras[0]);

                if ($extras[2] && ($extras[2] ne "")) {
                    set_footer(gettext("Written by ")
                          . $extras[1] . " - "
                          . $extras[2]);
                } else {
                    if ($extras[1]) {
                        set_footer(gettext("Written by ") . $extras[1]);
                    } else {
                        set_footer("");
                    }
                }
            }
            $line[2] =~ s/#BREAK#/\n/g;
            $line[2] =~ s/#SEMI#/:/g;
            $line[2] =~ s/<.*?>//g;
            set_maintext(fromutf($line[2]), NONE, $wrap);

            #reset_timer($globals->{'snapshot_timer'});
            #$globals->{'snapshot_timer'} = Glib::Idle->add(\&update_snapshot);
        } elsif (/^loopparent$/) {
            $LOOPPARENT = $line[1];
            debug("Set loop parent to: " . $LOOPPARENT);
        } elsif (/^get$/) {
            if ($line[1] eq "playlist") {
                $status = get_playlist($line[2]);
            } elsif ($line[1] eq "playlists") {
                $status = get_playlists();
            } elsif ($line[1] eq "status") {
                $status =
                  $current_list . ":" . $current_item . ":" . $current_point;
            }
        } elsif (/^display$/ && $line[1] ne "") {

            if (!(($line[1] eq "current") && $globals->{'blanked_state'})) {
                $globals->{'blanked_state'} = FALSE;

                #
                # Change it to lowercase
                $line[1] = lc($line[1]);

                # display new lyrics
                my $query =
                  "SELECT * FROM playlist WHERE playorder=" . $current_item;
                debug($query);
                my $sth = $lyricDbh->prepare($query)
                  || display_fatal($errorcodes->{'sqlprepare'}, $!);
                my $rv = $sth->execute
                  || display_fatal($errorcodes->{'sqlexecute'}, $!);
                my $current_play = $sth->fetchrow_hashref();

                if ($line[1] eq "playlist") {
                    debug("Changing playlist to " . $line[2]);
                    $current_list = $line[2];
                } elsif ($line[1] eq "current") {
                    $globals->{'blanked_state'} = FALSE;

                    # ignore and just display same page
                } elsif ($line[1] eq "next_page") {
                    my $query = "SELECT playlist FROM playlist WHERE playorder="
                      . $current_item;
                    debug($query);
                    my $sth = $lyricDbh->prepare($query)
                      || display_fatal($errorcodes->{'sqlprepare'}, $!);
                    my $rv = $sth->execute
                      || display_fatal($errorcodes->{'sqlexecute'}, $!);
                    my @row = $sth->fetchrow_array();
                    $query =
                        "SELECT MIN(playorder) FROM playlist WHERE playlist="
                      . $row[0]
                      . " AND playorder>"
                      . $current_item
                      . " ORDER BY playorder";
                    debug($query);
                    $sth = $lyricDbh->prepare($query)
                      || display_fatal($errorcodes->{'sqlprepare'}, $!);
                    $rv = $sth->execute
                      || display_fatal($errorcodes->{'sqlexecute'}, $!);
                    my @row2 = $sth->fetchrow_array();

                    if ($row2[0]) {

                        #End of this particular list (song/sublist) not reached
                        debug("Looping to next item in list\n");
                        $current_item = $row2[0];
                    } else {

                        #End of this particular list (song/sublist) reached
                        if ($line[2] eq "loop") {
                            debug("Finding next item to display in loop\n");

                            if ($LOOPPARENT == -1) {
                                debug("Looping a song, back to page 1\n");
                                $query =
"SELECT MIN(playorder) FROM playlist WHERE playlist="
                                  . $row[0];
                                debug($query);
                                $sth = $lyricDbh->prepare($query)
                                  || display_fatal($errorcodes->{'sqlprepare'},
                                    $!);
                                $rv = $sth->execute
                                  || display_fatal($errorcodes->{'sqlexecute'},
                                    $!);
                                my @row3 = $sth->fetchrow_array();
                                if ($row3[0]) {
                                    $current_item = $row3[0];
                                }
                            } else {
                                debug("Looping a sublist...\n");

                           #Build a 'context map', by tracing the
                           #steps from the current level, to the top of the list
                                debug("Building the context map...\n");
                                my @contextmap;    #array of playorders
                                my $item    = $current_item;
                                my $plpoint = -2;

                                while ($plpoint != $LOOPPARENT) {
                                    $query =
"SELECT playlist FROM playlist WHERE playorder="
                                      . $item;
                                    debug("\t" . $query);
                                    $sth = $lyricDbh->prepare($query)
                                      || display_fatal(
                                        $errorcodes->{'sqlprepare'}, $!);
                                    $rv = $sth->execute
                                      || display_fatal(
                                        $errorcodes->{'sqlexecute'}, $!);
                                    my @playlist = $sth->fetchrow_array();

                                    #Add playlist id to contextmap
                                    @contextmap = (@contextmap, $playlist[0]);

                                    #Update playlist pointer so we can do
                                    #the test for equality to LOOPPARENT
                                    $plpoint = $playlist[0];

                                    #Change item to this playlist's playorder
                                    $query =
"SELECT playorder FROM playlist WHERE data="
                                      . $playlist[0]
                                      . " and (type='sub' or type='play')";
                                    debug("\t" . $query);
                                    $sth = $lyricDbh->prepare($query)
                                      || display_fatal(
                                        $errorcodes->{'sqlprepare'}, $!);
                                    $rv = $sth->execute
                                      || display_fatal(
                                        $errorcodes->{'sqlexecute'}, $!);
                                    my @playorder = $sth->fetchrow_array();

                                    $item = $playorder[0];
                                    debug("....\n");
                                }
                                debug("Context map built!\n");

                                #Find the next item
                                my $lastpo   = $current_item;
                                my $nextitem = $current_item;

                                foreach (@contextmap) {

                                 #Find next item in the current context map list
                                    $query =
"SELECT MIN(playorder) FROM playlist WHERE "
                                      . " playlist="
                                      . $_
                                      . " and playorder > "
                                      . $lastpo;
                                    debug($query);
                                    $sth = $lyricDbh->prepare($query)
                                      || display_fatal(
                                        $errorcodes->{'sqlprepare'}, $!);
                                    $rv = $sth->execute
                                      || display_fatal(
                                        $errorcodes->{'sqlexecute'}, $!);
                                    my @results = $sth->fetchrow_array();

                                    if ($results[0]) {

                                        #Set nextitem and leave loop
                                        $nextitem = $results[0];
                                        last;
                                    } else {

                                        #prepare for next iteration
                                        $query =
"SELECT playorder FROM playlist WHERE "
                                          . " data="
                                          . $_
                                          . " and (type='sub'"
                                          . " or type='play')";

                                        debug("\t" . $query);
                                        $sth = $lyricDbh->prepare($query)
                                          || display_fatal(
                                            $errorcodes->{'sqlprepare'}, $!);
                                        $rv = $sth->execute
                                          || display_fatal(
                                            $errorcodes->{'sqlexecute'}, $!);
                                        my @poresult = $sth->fetchrow_array();

                                        $lastpo = $poresult[0];
                                    }
                                }

                                if ($current_item != $nextitem) {
                                    debug("Found next item to show\n");
                                    $current_item = $nextitem;
                                } else {

                                    #End of the road, go back to start!
                                    debug("No more items, back to start\n");
                                    $query =
"SELECT MIN(playorder) FROM playlist WHERE "
                                      . " playlist="
                                      . $LOOPPARENT;
                                    debug($query);
                                    $sth = $lyricDbh->prepare($query)
                                      || display_fatal(
                                        $errorcodes->{'sqlprepare'}, $!);
                                    $rv = $sth->execute
                                      || display_fatal(
                                        $errorcodes->{'sqlexecute'}, $!);
                                    my @start = $sth->fetchrow_array();
                                    $current_item = $start[0];
                                }
                            }
                        }
                    }
                } elsif ($line[1] eq "prev_page") {
                    my $query = "SELECT playlist FROM playlist WHERE playorder="
                      . $current_item;
                    debug($query);
                    my $sth = $lyricDbh->prepare($query)
                      || display_fatal($errorcodes->{'sqlprepare'}, $!);
                    my $rv = $sth->execute
                      || display_fatal($errorcodes->{'sqlexecute'}, $!);
                    my @row = $sth->fetchrow_array();
                    $query =
                        "SELECT MAX(playorder) FROM playlist WHERE playlist="
                      . $row[0]
                      . " AND playorder<"
                      . $current_item
                      . " ORDER BY playorder";
                    debug($query);
                    $sth = $lyricDbh->prepare($query)
                      || display_fatal($errorcodes->{'sqlprepare'}, $!);
                    $rv = $sth->execute
                      || display_fatal($errorcodes->{'sqlexecute'}, $!);
                    my @row2 = $sth->fetchrow_array();

                    if ($row2[0]) {
                        $current_item = $row2[0];
                    } else {
                        if ($line[2] eq "loop") {
                            $query =
"SELECT MAX(playorder) FROM playlist WHERE playlist="
                              . $row[0];
                            debug($query);
                            $sth = $lyricDbh->prepare($query)
                              || display_fatal($errorcodes->{'sqlprepare'}, $!);
                            $rv = $sth->execute
                              || display_fatal($errorcodes->{'sqlexecute'}, $!);
                            my @row2 = $sth->fetchrow_array();
                            if ($row2[0]) {
                                $current_item = $row2[0];
                            }
                        }
                    }

                } elsif ($line[1] eq "next_song") {
                    my $query =
"SELECT a.playorder,a.playlist FROM playlist AS a, playlist AS b WHERE a.data=b.playlist AND a.type=\"play\" AND b.playorder="
                      . $current_item;
                    debug($query);
                    my $sth = $lyricDbh->prepare($query)
                      || display_fatal($errorcodes->{'sqlprepare'}, $!);
                    my $rv = $sth->execute
                      || display_fatal($errorcodes->{'sqlexecute'}, $!);
                    my @row;
                    if (@row = $sth->fetchrow_array()) {
                        $current_item = $row[0];
                        $current_list = $row[1];
                    }

                    $query =
                        "SELECT MIN(playorder) FROM playlist WHERE playorder > "
                      . $current_item
                      . " AND playlist="
                      . $current_list;
                    debug($query);
                    $sth = $lyricDbh->prepare($query)
                      || display_fatal($errorcodes->{'sqlprepare'}, $!);
                    $rv = $sth->execute
                      || display_fatal($errorcodes->{'sqlexecute'}, $!);
                    @row = $sth->fetchrow_array();

                    if (defined $row[0]) {
                        $current_item = $row[0];
                    }
                } elsif ($line[1] eq "prev_song") {
                    my $query =
"SELECT a.playorder,a.playlist FROM playlist AS a, playlist AS b WHERE a.data=b.playlist AND a.type=\"play\" AND b.playorder="
                      . $current_item;
                    debug($query);
                    my $sth = $lyricDbh->prepare($query)
                      || display_fatal($errorcodes->{'sqlprepare'}, $!);
                    my $rv = $sth->execute
                      || display_fatal($errorcodes->{'sqlexecute'}, $!);
                    my @row;
                    if (@row = $sth->fetchrow_array()) {
                        $current_item = $row[0];
                        $current_list = $row[1];
                    }

                    $query =
                        "SELECT MAX(playorder) FROM playlist WHERE playorder < "
                      . $current_item
                      . " AND playlist="
                      . $current_list;
                    debug($query);
                    $sth = $lyricDbh->prepare($query)
                      || display_fatal($errorcodes->{'sqlprepare'}, $!);
                    $rv = $sth->execute
                      || display_fatal($errorcodes->{'sqlexecute'}, $!);
                    @row = $sth->fetchrow_array();

                    if (defined $row[0]) {
                        $current_item = $row[0];
                    }
                } elsif ($line[1] eq "page") {
                    my $query = "SELECT playlist FROM playlist WHERE playorder="
                      . $current_item;
                    debug($query);
                    my $sth = $lyricDbh->prepare($query)
                      || display_fatal($errorcodes->{'sqlprepare'}, $!);
                    my $rv = $sth->execute
                      || display_fatal($errorcodes->{'sqlexecute'}, $!);
                    my @row = $sth->fetchrow_array();

                    $query =
                        "SELECT playorder FROM playlist WHERE playlist="
                      . $row[0]
                      . " ORDER BY playorder";
                    debug($query);
                    $sth = $lyricDbh->prepare($query)
                      || display_fatal($errorcodes->{'sqlprepare'}, $!);
                    $rv = $sth->execute
                      || display_fatal($errorcodes->{'sqlexecute'}, $!);
                    my $count = 0;

                    while (($count < $line[2])
                        && (@row = $sth->fetchrow_array()))
                    {
                        $count++;
                    }
                    if (defined $row[0]) {
                        $current_item = $row[0];
                    }

                } else {
                    $current_item = $line[1];
                    $preview_item = 0;
                }

                # load lyrics from DB

                if ($preview_item) {
                    my $tmp = $current_item;
                    $current_item = $preview_item;
                    $preview_item = $tmp;
                }
                $query =
                  "SELECT * FROM playlist WHERE playorder=" . $current_item;
                debug($query);
                $sth = $lyricDbh->prepare($query)
                  || display_fatal($errorcodes->{'sqlprepare'}, $!);
                $rv = $sth->execute
                  || display_fatal($errorcodes->{'sqlexecute'}, $!);
                my $row = $sth->fetchrow_hashref();
                if (   $row->{'type'} ne "back"
                    && $row->{'type'} ne "file"
                    && $row->{'type'} ne "imag")
                {

                    #Check for associate image and, if present, apply it.
                    my $imgquery =
                      "SELECT imagename FROM associations WHERE playlist="
                      . $current_item;
                    debug($imgquery);
                    my $imgsth = $lyricDbh->prepare($imgquery)
                      || display_fatal($errorcodes->{'sqlprepare'}, $!);
                    $imgsth->execute
                      || display_fatal($errorcodes->{'sqlexecute'}, $!);

                    if (my $imgrow = $imgsth->fetchrow_hashref()) {
                        change_backdrop($imgrow->{'imagename'});
                        $bgimage_changed = TRUE;
                    } else {

                        # If the song has changed then then check parent and set
                        # background if one is associated with it
                        my $parentquery =
"SELECT a.imagename,q.data FROM associations as a, playlist AS p, playlist AS q WHERE p.type='play' AND p.data=q.playlist and a.playlist=p.playorder AND q.playorder="
                          . $current_item;
                        debug($parentquery);
                        my $imgsth = $lyricDbh->prepare($parentquery)
                          || display_fatal($errorcodes->{'sqlprepare'}, $!);
                        $imgsth->execute
                          || display_fatal($errorcodes->{'sqlexecute'}, $!);
                        if (my $imgrow = $imgsth->fetchrow_hashref()) {
                            change_backdrop($imgrow->{'imagename'});
                            $bgimage_changed = TRUE;
                        } else {
                            if ($bgimage_changed && $imgrow->{'data'} ne "imag")
                            {

                                #Reset background if an image was shown
                                change_backdrop($config->{'BGImage'});
                                $bgimage_changed = FALSE;
                            }
                        }
                    }
                }

                if ($exec_pid > 0) {
                    debug("Killing " . $exec_pid);
                    system('kill ' . $exec_pid);
                    system('kill -9 ' . $exec_pid);
                    $exec_pid = 0;
                }

                if (defined $row) {
                    if ($row->{'type'} eq "back") {
                        my $file = $row->{'data'};
                        $config->{'BGImage'} = $file;
                        change_backdrop($file);
                    } elsif ($row->{'type'} eq "file") {
                        if (-r $row->{'data'}) {
                            $bgimage_changed = TRUE;
                            set_footer("");
                            set_header("");
                            set_maintext("", NONE, FALSE);
                            change_backdrop("dir;" . $row->{'data'});
                        }
                    } elsif ($row->{'type'} eq "imag") {
                        $bgimage_changed = TRUE;
                        set_footer("");
                        set_header("");
                        set_maintext("", NONE, FALSE);
                        change_backdrop($row->{'data'});
                    } elsif ($row->{'type'} eq "vers") {

                        # Kill invalid points from previous songs
                        $current_point = -1;
                        @points        = ();

                        my $query =
"SELECT * FROM playlist,playlists WHERE playlist.playlist=playlists.id AND playorder="
                          . $current_item;
                        debug($query);
                        my $sth = $lyricDbh->prepare($query)
                          || display_fatal($errorcodes->{'sqlprepare'}, $!);
                        my $rv = $sth->execute
                          || display_fatal($errorcodes->{'sqlexecute'}, $!);

                        my $row        = $sth->fetchrow_hashref();
                        my $transition = $row->{'transition'};

                        my $versetext = $row->{'title'};
                        my @line      = split(/[:-]/, $row->{'title'});
                        my $verses    = $row->{'data'};
                        my $verse     = "";

                        ($line[2], $line[4]) = split(/-/, $row->{'data'});
                        if ($line[4] eq "") {
                            $line[4] = $line[2];
                        }
                        if (!$globals->{'usesword'}) {
                            $query = "SELECT book FROM verse WHERE book LIKE \""
                              . $line[0] . "%\"";
                            $sth = $bibleDbh->prepare($query)
                              || display_fatal($errorcodes->{'sqlprepare'}, $!);
                            $rv = $sth->execute
                              || display_fatal($errorcodes->{'sqlexecute'}, $!);
                            my @bookrow = $sth->fetchrow_array();
                            $line[0] = $bookrow[0];

                            if ($line[1] == $line[3]) {
                                $query =
                                    "SELECT * FROM  verse WHERE book LIKE \""
                                  . $line[0]
                                  . "%\" AND chapternum="
                                  . $line[1]
                                  . " AND versenum>="
                                  . $line[2]
                                  . " AND versenum <= "
                                  . $line[4];
                            } else {
                                $query =
                                    "SELECT * FROM verse WHERE book LIKE \""
                                  . $line[0]
                                  . "%\" AND ((chapternum="
                                  . $line[1]
                                  . " AND versenum>="
                                  . $line[2]
                                  . ") OR (chapternum>"
                                  . $line[1]
                                  . " AND chapternum<"
                                  . $line[3]
                                  . ") OR (chapternum="
                                  . $line[3]
                                  . " AND versenum<="
                                  . $line[4] . "))";
                            } ## end else
                            debug($query);
                            $sth = $bibleDbh->prepare($query)
                              || display_fatal($errorcodes->{'sqlprepare'}, $!);
                            $rv = $sth->execute
                              || display_fatal($errorcodes->{'sqlexecute'}, $!);

                            while ($row = $sth->fetchrow_hashref()) {
                                my $line =
                                    $row->{'chapternum'} . ":"
                                  . $row->{'versenum'} . "   "
                                  . $row->{'verse'};
                                $verse .= $line . "\n";
                            }
                        } else {
                            my $command = "";
                            $command = sprintf(
"%s -b %s -e UTF8 -k '%s' %d:%d-%d:%d |tr \\\\n \'#\'",
                                $globals->{'diatheke'}, $globals->{'bibledb'},
                                $line[0],               $line[1],
                                $line[2],               $line[3],
                                $line[4],               $line[0]
                            );
                            debug($command);
                            my $command_out = `$command`;
                            ($line[0], undef) = split(/\s\d/, $command_out, 2);
                            my @command_lines =
                              split(/\#/,, $command_out);

                            foreach (@command_lines) {
                                chomp;
                                my $line2 = $_;
                                $line2 =~ s/^$line[0] //g;
                                if ($line2 ne "") {
                                    $verse .= $line2 . "\n";
                                }
                            }
                        }

                        set_header($versetext);
                        set_footer($globals->{'biblename'});
                        set_maintext($verse, $transition, TRUE);
                        $status =
                            gettext("Displaying ")
                          . $versetext
                          . gettext(" verses ")
                          . $verses;
                    } elsif ($row->{'type'} eq "play" | $row->{'type'} eq "sub")
                    {
                        my $query =
                            "SELECT * FROM playlist WHERE playlist="
                          . $row->{'data'}
                          . " ORDER BY playorder";
                        debug($query);
                        $sth = $lyricDbh->prepare($query)
                          || display_fatal($errorcodes->{'sqlprepare'}, $!);
                        my $rv = $sth->execute
                          || display_fatal($errorcodes->{'sqlexecute'}, $!);
                        my $row = $sth->fetchrow_hashref();
                        update_display("display", $row->{'playorder'}, 0);

                    } else {
                        my $query2 =
"SELECT title,artist,lyrics,copyright,pagenum FROM lyricMain AS l, page AS pa WHERE pa.songid=l.id AND pa.pageid="
                          . $row->{'data'};
                        debug($query2);
                        my $sth2 = $lyricDbh->prepare($query2)
                          || display_fatal($errorcodes->{'sqlprepare'}, $!);
                        my $rv2 = $sth2->execute
                          || display_fatal($errorcodes->{'sqlexecute'}, $!);
                        my $row2 = $sth2->fetchrow_hashref();

                        $row2->{'lyrics'} =~ s/
/\n/g;
                        my $footer = "";
                        if ($row2->{'artist'} ne "") {
                            $footer =
                              gettext("Written by ") . $row2->{'artist'};
                        }
                        if ($row2->{'copyright'} ne "") {
                            if ($row2->{'copyright'} =~ /^Preset/) {
                                $row2->{'copyright'} =~ s/^.*([0-9]).*$/$1/g;
                                $footer .=
                                  " - " . $preset[$row2->{'copyright'}];
                            } else {
                                $footer .= " - " . $row2->{'copyright'};
                            }
                        }

                        # Determine if this is a multi-point page
                        if ($row2->{'lyrics'} =~ m/<UL>/) {
                            debug("This page has multiple points...");
                            $current_point = 1;
                            @points = split(/<LI>/, $row2->{'lyrics'});
                            my $pointtext = $points[$current_point];

                            #Now figure out how many \n's to add
                            if (my @o = ($row2->{'lyrics'} =~ /\n/g)) {
                                if (my @n = $pointtext =~ /\n/g) {
                                    my $x;
                                    for (
                                        $x = 0 ;
                                        $x < scalar(@o) - scalar(@n) ;
                                        $x++
                                      )
                                    {
                                        $pointtext .= "\n";
                                    }
                                }
                            }
                            $row2->{'lyrics'} = $pointtext;
                        } else {
                            $current_point = -1;
                            @points        = ();
                        }
                        $row2->{'lyrics'} =~ s/<.*?>//g;
                        set_header($row2->{'title'});
                        set_footer($footer);
                        set_maintext($row2->{'lyrics'}, $row->{'transition'},
                            FALSE);
                        $status =
                            gettext("Displaying ")
                          . $row2->{'title'}
                          . gettext(" page ")
                          . $row2->{'pagenum'};
                    } ## end else
                    refresh_screen();
                } ## end if (my $row = $sth->fetchrow_hashref...
                if ($preview_item) {
                    $current_item = $preview_item;
                    $preview_item = 0;
                }

                #reset_timer($globals->{'snapshot_timer'});
                #$globals->{'snapshot_timer'} =
                #Glib::Idle->add(\&update_snapshot);
            }
        } elsif (/^media$/) {
            if ($line[1] eq "pause") {
                debug("Toggling Play/Pause media");
                if ($MINISERV < 0) {
                    eval {
                        $globals->{'background'}
                          ->set_playing(!$globals->{'background'}->get_playing);
                    };
                }
            }
        }
    } ## end if ($_)
    debug("The status message sent is: " . Encode::decode("utf8", $status));
    update_tracker();
    return $status;
} ## end sub process_input
    #***

#****f* lyricue_server/CloseAppWindow
# NAME
#   CloseAppWindow
# SYNOPSIS
#   CloseAppWindow ()
# FUNCTION
#   Close the lyricue_server window
# INPUTS
#   None
# OUTPUT
#   None
# SOURCE
#
sub CloseAppWindow {
    debug("Exiting Child");
    if ($globals->{'server_type'} == SIMPLE) {
        unlink $globals->{'bg_file'};
        $globals->{'window'}->destroy;
    } elsif ($globals->{'server_type'} == CLUTTER) {
    } else {
        $globals->{'window'}->destroy;
    }

    # Re-enable screensaver
    system('xset s on +dpms');

    exit;
    return FALSE;
}

#***

#****f* lyricue_server/HandleKey
# NAME
#   HandleKey
# SYNOPSIS
#   HandleKey ( $widget, $data )
# FUNCTION
#   Parses keyboard input
# INPUTS
#   $widget - Calling widget
#   $data   - structure containing event
# OUTPUT
#   calls update_display to update screen
# SOURCE
#
sub HandleKey {
    my ($widget, $data) = @_;

    if (   ($data->keyval == $Gtk2::Gdk::Keysyms{Left})
        || ($data->keyval == $Gtk2::Gdk::Keysyms{KP_Left})
        || ($data->keyval == $Gtk2::Gdk::Keysyms{Page_Up}))
    {
        update_display("display", "prev_page", $config->{'Loop'});
    } elsif (($data->keyval == $Gtk2::Gdk::Keysyms{Up})
        || ($data->keyval == $Gtk2::Gdk::Keysyms{KP_Up}))
    {
        update_display("display", "prev_song", 0);
    } elsif (($data->keyval == $Gtk2::Gdk::Keysyms{Right})
        || ($data->keyval == $Gtk2::Gdk::Keysyms{KP_Right})
        || ($data->keyval == $Gtk2::Gdk::Keysyms{Page_Down}))
    {
        update_display("display", "next_page", $config->{'Loop'});
    } elsif (($data->keyval == $Gtk2::Gdk::Keysyms{Down})
        || ($data->keyval == $Gtk2::Gdk::Keysyms{KP_Down}))
    {
        update_display("display", "next_song", 0);
    } elsif (($data->keyval == $Gtk2::Gdk::Keysyms{KP_0})
        || ($data->keyval == $Gtk2::Gdk::Keysyms{KP_Insert})
        || ($data->keyval == $Gtk2::Gdk::Keysyms{b}))
    {
        update_display("blank", 0, 0);
    } elsif ($data->keyval == $Gtk2::Gdk::Keysyms{p}) {
        update_display("media", "pause", 0);
    } elsif ($data->keyval == $Gtk2::Gdk::Keysyms{Q}) {

        # exit
        my $dialog = Gtk2::Dialog->new(
            'Confirm Exit', undef, 'modal',
            'gtk-ok'     => 'ok',
            'gtk-cancel' => 'cancel',
        );
        $dialog->vbox->pack_start(
            Gtk2::Label->new(
                "Are you sure you want to close the Lyricue Server?"),
            TRUE, TRUE, 0
        );
        $dialog->show_all();
        my $response = $dialog->run;
        print("Response: " . $response . "\n");
        $dialog->destroy;
        if ($response eq "ok") {
            CloseAppWindow();
        }
    } else {
        debug("Unknown key: " . $data->keyval);
        return FALSE;
    }
    return TRUE;
} ## end sub HandleKey

#***

#****f* lyricue_server/change_backdrop
# NAME
#   change_backdrop
# SYNOPSIS
#   change_backdrop ( $id )
# FUNCTION
#   Loads an image and sets it as the screens background
# INPUTS
#   $id - id of image
# OUTPUT
#   Updates screen
# SOURCE
#
sub change_backdrop {
    my ($id) = @_;
    if ($id eq $globals->{'bgid'}) {
        debug("Backdrop ID same - not changing");
        return;
    } 
    debug("Setting backdrop to $id");
    $globals->{'bgid'} = $id;
    my ($type, $data) = split /;/, $id;
    if ($data eq "") {
        $data = $type;
        $type = "db";
    }
    if ($type eq "special") {
        debug("Changing backdrop to live video feed");
        if (defined $globals->{'background'}) {
            $globals->{'background'}->destroy();
            undef $globals->{'background'};
        }
        if ($MINISERV < 0) {
            $globals->{'background'} = Clutter::Gst::VideoTexture->new();
            my $playbin = $globals->{'background'}->get_playbin();
            use GStreamer;
            my $pipeline = GStreamer::Pipeline->new("");
            my $src = GStreamer::ElementFactory->make("v4l2src", "src");
            my $colorspace =
              GStreamer::ElementFactory->make("ffmpegcolorspace", "colorspace");
            my $sink = Clutter::Gst::VideoSink->new($globals->{'background'});
            $pipeline->add($src, $colorspace, $sink);
            $src->link($colorspace, $sink);
            $globals->{'background'}->set(
                keep_aspect_ratio => 1,
                request_mode      => 'height-for-width',
            );
            $globals->{'background'}
              ->set_width($globals->{'stage'}->get_width());
            $globals->{'background'}->set_anchor_point(
                $globals->{'background'}->get_width / 2,
                $globals->{'background'}->get_height / 2
            );
            $globals->{'background'}
              ->set_position($globals->{'stage'}->get_width / 2, 0);
            $globals->{'stage'}->add($globals->{'background'});

            if ($MINISERV < 0) {
                $pipeline->set_state('GST_STATE_PLAYING');
            }
            $globals->{'video_playing'} = TRUE;
        }
    } elsif ($type eq "dir") {

        # Movie file
        my @fileexts = qw(avi mpg mov wmv mp4);
        my $video    = FALSE;
        if ($MINISERV < 0) {
            for my $fileobj (@fileexts) {
                if ($data =~ /$fileobj$/i) {
                    debug("Changing backdrop video to file:" . $data);
                    $video = TRUE;
                    if ($globals->{'server_type'} == CLUTTER) {
                        debug("Clutter Video");
                        if (defined $globals->{'background'}) {
                            $globals->{'background'}->destroy();
                            undef $globals->{'background'};
                        }
                        $globals->{'background'} =
                          Clutter::Gst::VideoTexture->new();
                        $globals->{'background'}->set_filename($data);
                        $globals->{'background'}->set(
                            keep_aspect_ratio => 1,
                            request_mode      => 'height-for-width',
                        );
                        $globals->{'background'}
                          ->set_width($globals->{'stage'}->get_width());
                        $globals->{'background'}->set_anchor_point(
                            $globals->{'background'}->get_width / 2,
                            $globals->{'background'}->get_height / 2
                        );
                        $globals->{'background'}
                          ->set_position($globals->{'stage'}->get_width / 2, 0);
                        $globals->{'stage'}->add($globals->{'background'});

                        if ($MINISERV < 0) {
                            $globals->{'background'}->set_playing(TRUE);
                        }
                        $globals->{'video_playing'} = TRUE;
                    } else {
                        $exec_pid = fork;
                        if ($exec_pid > 0) {

                            my $command = $config->{'MPlayer'} . " " . $data;
                            debug($command);

                            system($command);
                        }
                    }
                }
            }
        }
        if (!$video) {
            debug("Changing backdrop image to file:" . $data);
            if (($globals->{'server_type'} == SIMPLE)) {
                $globals->{'bg_file'} = $data;
            } elsif ($globals->{'server_type'} == CLUTTER) {
                if (defined $globals->{'background'}) {
                    if (defined $globals->{'background_old'}) {
                        $globals->{'background_old'}->destroy();
                        undef $globals->{'background_old'};
                    }
                    $globals->{'background_old'} = $globals->{'background'};
                    $globals->{'timeline_bg'} =
                      Clutter::Timeline->new_for_duration(100);
                    $globals->{'timeline_bg'}->set_speed(15);
                    my $alpha = Clutter::Alpha->new($globals->{'timeline_bg'},
                        \&Clutter::Alpha::ramp_inc);
                    $globals->{'timeline_bg'}->signal_connect(
                        'new-frame' => sub {
                            my ($self, $alpha_value) = @_;
                            if (defined $globals->{'background_old'}) {
                                $globals->{'background_old'}->set_opacity(
                                    (1 - $self->get_progress) * 255);
                            }
                        }
                    );
                    $globals->{'timeline_bg'}->signal_connect(
                        'completed' => sub {
                            if (defined $globals->{'background_old'}) {
                                $globals->{'background_old'}->destroy();
                                undef $globals->{'background_old'};
                            }
                            undef $globals->{'timeline_bg'};
                        }
                    );
                    $globals->{'timeline_bg'}->start();
                }
                if (-r $data) {
                    $globals->{'background'} = Clutter::Texture->new($data);
                    $globals->{'background'}->set(
                        keep_aspect_ratio => 1,
                        request_mode      => 'width-for-height',
                    );
                    $globals->{'background'}
                      ->set_height($globals->{'stage'}->get_height());
                    $globals->{'background'}->set_anchor_point(
                        $globals->{'background'}->get_width / 2,
                        $globals->{'background'}->get_height / 2
                    );
                    $globals->{'background'}->set_position(
                        $globals->{'stage'}->get_width / 2,
                        $globals->{'stage'}->get_height / 2
                    );
                    $globals->{'stage'}->add($globals->{'background'});
                }
            } else {
                my ($pixbuf);
                eval {
                    $pixbuf =
                      Gtk2::Gdk::Pixbuf->new_from_file_at_size($data,
                        $config->{'Width'}, $config->{'Height'});
                };
                if ($@) {
                    debug("Unable to load background: $data");
                } else {
                    if (defined $background) {
                        $background->destroy;
                    }
                    $background = Gnome2::Canvas::Item->new(
                        $globals->{'root'}, 'Gnome2::Canvas::Pixbuf',
                        pixbuf     => $pixbuf,
                        x          => 0,
                        y          => 0,
                        width      => $config->{'Width'},
                        height     => $config->{'Height'},
                        width_set  => TRUE,
                        height_set => TRUE,
                    );
                }
            }
        }
    } else {
        my $query =
"SELECT format, description, data, textcolour, shadowcolour FROM media WHERE id=\""
          . $data . "\"";
        debug($query);
        my $sth = $mediaDbh->prepare($query)
          || display_fatal($errorcodes->{'sqlprepare'}, $!);
        my $rv = $sth->execute
          || display_fatal($errorcodes->{'sqlexecute'}, $!);
        my $row = $sth->fetchrow_hashref();
        if ($row) {

            if (   ($row->{'textcolour'} ne "")
                && ($row->{'textcolour'} ne NULL)
                && ($row->{'textcolour'} ne "Default")
                && ($row->{'textcolour'} ne "NULL"))
            {
                debug("Changing text colour to " . $row->{'textcolour'});
                $config->{'BackdropTextColour'} = $row->{'textcolour'};
            } else {
                $config->{'BackdropTextColour'} =
                  $config->{'DefaultBackdropTextColour'};
            }
            if (   ($row->{'shadowcolour'} ne "")
                && ($row->{'shadowcolour'} ne NULL)
                && ($row->{'shadowcolour'} ne "Default")
                && ($row->{'shadowcolour'} ne "NULL"))
            {
                debug("Changing shadow colour to " . $row->{'shadowcolour'});
                $config->{'BackdropShadowColour'} = $row->{'shadowcolour'};
            } else {
                $config->{'BackdropShadowColour'} =
                  $config->{'DefaultBackdropShadowColour'};
            }

            if ($row->{'format'} eq "bg") {
                debug("Changing backdrop colour to " . $row->{'description'});
                if ($globals->{'server_type'} == SIMPLE) {
                    open(BGIMG, ">" . $globals->{'bg_file'});
                    print BGIMG
                      sprintf(
'/* XPM */\nstatic char *b[] = { "1 1 1 1", "  c %s", " " };\n',
                        $row->{'description'});
                    close BGIMG;
                } elsif ($globals->{'server_type'} == CLUTTER) {
                    if (defined $globals->{'background'}) {
                        $globals->{'background'}->destroy();
                        undef $globals->{'background'};
                    }
                    $globals->{'background'} = Clutter::Rectangle->new();
                    $globals->{'background'}->set_size(
                        $globals->{'stage'}->get_width(),
                        $globals->{'stage'}->get_height()
                    );
                    $globals->{'background'}->set_position(0, 0);
                    $globals->{'background'}
                      ->set_color(Clutter::Color->parse($row->{'description'}));
                    $globals->{'stage'}->add($globals->{'background'});
                    $globals->{'background'}->lower_bottom();
                    return;
                } else {
                    if (defined $background) {
                        $background->destroy;
                    }

                    $background = Gnome2::Canvas::Item->new(
                        $globals->{'root'}, 'Gnome2::Canvas::Rect',
                        x1          => 0,
                        y1          => 0,
                        x2          => $config->{'Width'},
                        y2          => $config->{'Height'},
                        fill_color  => $row->{'description'},
                        width_units => 0
                    );
                }
            } else {
                debug("Changing backdrop image to " . $row->{'description'});
                my $pixbuf_loader = Gtk2::Gdk::PixbufLoader->new();
                eval { $pixbuf_loader->write($row->{'data'}); };
                eval { $pixbuf_loader->close() };
                if ($@) {
                    debug("Unable to load background: $row->{'description'}");
                } else {
                    my $pixbuf     = $pixbuf_loader->get_pixbuf();
                    my $tmp_width  = $pixbuf->get_width;
                    my $tmp_height = $pixbuf->get_height;
                    my $scale      = 1;
                    my $offset_x   = 0;
                    my $offset_y   = 0;
                    my $aspect     = $config->{'Width'} / $config->{'Height'};
                    if (($tmp_width / $tmp_height) > $aspect) {
                        $scale = $config->{'Width'} / $tmp_width;
                        $offset_y =
                          ($config->{'Height'} - ($tmp_height * $scale)) / 2;
                    } else {
                        $scale = $config->{'Height'} / $tmp_height;
                        $offset_x =
                          ($config->{'Width'} - ($tmp_width * $scale)) / 2;
                    }
                    if ($globals->{'server_type'} == SIMPLE) {
                        $pixbuf->save($globals->{'bg_file'}, 'png');
                    } elsif ($globals->{'server_type'} == CLUTTER) {
                        $pixbuf->save($globals->{'bg_file'}, 'png');
                        if (defined $globals->{'background'}) {
                            $globals->{'background'}->destroy();
                            undef $globals->{'background'};
                        }
                        $globals->{'background'} =
                          Clutter::Texture->new($globals->{'bg_file'});
                        $globals->{'background'}->set(
                            keep_aspect_ratio => 1,
                            request_mode      => 'width-for-height',
                        );
                        $globals->{'background'}
                          ->set_height($globals->{'stage'}->get_height());
                        $globals->{'background'}->set_anchor_point(
                            $globals->{'background'}->get_width / 2,
                            $globals->{'background'}->get_height / 2
                        );
                        $globals->{'background'}->set_position(
                            $globals->{'stage'}->get_width / 2,
                            $globals->{'stage'}->get_height / 2
                        );
                        $globals->{'stage'}->add($globals->{'background'});
                    } else {
                        if (defined $background) {
                            $background->destroy;
                        }
                        $background = Gnome2::Canvas::Item->new(
                            $globals->{'root'}, 'Gnome2::Canvas::Pixbuf',
                            pixbuf     => $pixbuf,
                            x          => $offset_x,
                            y          => $offset_y,
                            width      => $tmp_width * $scale,
                            height     => $tmp_height * $scale,
                            width_set  => TRUE,
                            height_set => TRUE,
                        );
                    }
                }
            }
        }
    }
    if ($globals->{'server_type'} == SIMPLE) {
        my $rc_style = Gtk2::RcStyle->new;
        $rc_style->bg_pixmap_name('normal', $globals->{'bg_file'});
        $globals->{'window'}->modify_style($rc_style);
    } elsif ($globals->{'server_type'} == CLUTTER) {
        if ($globals->{'background'}) {
            $globals->{'background'}->lower_bottom();
        }
    } else {
        $background->lower_to_bottom;
        $background_black->lower_to_bottom;
    }
} ## end sub change_backdrop

#***

#****f* lyricue_server/update_display
# NAME
#   update_display
# SYNOPSIS
#   update_display ( $command, $primary, $secondary, $tertiary)
# FUNCTION
#   Prints text to FIFO in predetermined format
# INPUTS
#   $command   - Main command to send
#   $primary   - Primary parameter to command
#   $secondary - Secondary parameter to send
#   $tertiary  - Tertiary parameter to send
# OUTPUT
#   Sends it all to the socket
# SOURCE
#
sub update_display {
    my ($command, $primary, $secondary) = @_;

    if (
        my $server = IO::Socket::INET->new(
            Proto    => "tcp",
            PeerAddr => "localhost",
            PeerPort => $globals->{'use_port'}
        )
      )
    {
        print $server $command . ":" . $primary . ":" . $secondary . "\n";
        close($server);
    }
} ## end sub update_display

sub update_miniview {
    my ($command) = @_;

    if (
        my $server = IO::Socket::INET->new(
            Proto    => "tcp",
            PeerAddr => "localhost",
            PeerPort => $globals->{'miniview_port'}
        )
      )
    {
        print $server $command;
        close($server);
    }
} ## end sub update_miniview

#***

#****f* lyricue_server/debug
# NAME
#   debug
# SYNOPSIS
#   debug ( $text )
# FUNCTION
#   Checks if $DEBUG is set and if so outputs text to STDERR
# INPUTS
#   $text - text to output
# OUTPUT
#   $text to STDERR
# SOURCE
#
sub debug {
    if ($DEBUG) {
        my $text = shift;
        chomp($text);
        if ($text) {
            my ($sec, $min, $hour, undef) = localtime(time);
            print STDERR $hour . ":" . $min . ":" . $sec . "|";
            if ($MINISERV > 0) {
                print STDERR "SERVER: ";
            }
            print STDERR $text . "\n";
        }
    }
} ## end sub debug

#***

#****f* lyricue_server/change_to_db
# NAME
#   change_to_db
# SYNOPSIS
#   change_to_db ( $db )
# FUNCTION
#   Disconnects old bible database and loads a new one
# INPUTS
#   $text - text to output
# OUTPUT
#   No visible output except outputs to STDERR via debug
# SOURCE
#
sub change_to_db {
    my ($db, $type) = @_;
    $globals->{'bibledb'} = $db;
    if (!$globals->{'usesword'}) {
        $bibleDbh->disconnect;
    }
    if ($type eq "db") {
        $bibleDbh =
          db_connect($globals->{'bibledb'},
            $errorcodes->{'bibledbopen'} . $globals->{'bibledb'});
        $globals->{'usesword'} = FALSE;
    } else {
        $globals->{'usesword'} = TRUE;
        $bibleDbh = "";
    }
    $globals->{'biblename'} = $config->{'Bibles'}->{$globals->{'bibledb'}};
    $globals->{'biblename'} =~ s/^.*?://g;
    $globals->{'biblename'} =~ s/^.*?;//g;
    $globals->{'biblename'} =~ s/_//g;
} ## end sub debug

#****f* lyricue_server/check_socket
# NAME
#   check_socket
# SYNOPSIS
#   check_socket ($socket, $condition, $flags)
# FUNCTION
#   Check the socket for new data and handle it
# INPUTS
#   $socket - Socket to listen to
#   $condition - flags if something is on socket
#   $flags - Flags describing socket
# OUTPUT
#   No visible output except outputs to STDERR via debug
# SOURCE
#
sub check_socket {
    my ($socket, $condition, $flags) = @_;
    my $new_sock = $socket->accept();
    while (defined($_ = <$new_sock>)) {
        my $value = $_;
        my $stat  = process_input($value);
        chomp($stat);
        print $new_sock $stat . "\n";

        # Forward onto miniserver (if not the miniserver)
        if ($globals->{'use_port'} == $globals->{'server_port'}) {
            update_miniview($value);
        }
    }
    close($new_sock);

    return TRUE;
}

#***

sub load_config {
    my ($conf);
    debug("Loading Preferences from " . $globals->{'configfile'});
    my $bibleCount = 0;
    my $appCount   = 0;
    open(CONFIG, $globals->{'configfile'})
      || display_fatal("Couldn't open config file", $!);
    $conf->{'Width'}  = 0;
    $conf->{'Height'} = 0;
    while (<CONFIG>) {
        chomp;
        my @line = split(/=/);
        $line[0] =~ s/ *$//g;
        $line[1] =~ s/ *$//g;
        if (!$line[1]) {
            $line[1] = "";
        }
        $line[1] =~ s/^ *//g;
        if ($line[0] eq "App") {
            $conf->{'App'}[$appCount++] = $line[1];
        } else {
            $conf->{$line[0]} = $line[1];
        }
    }
    $conf->{'AppCount'} = $appCount;
    $conf->{'Bibles'}   = get_bibles();
    if (!defined($conf->{'MPlayer'})) {
        $conf->{'MPlayer'} =
          "mplayer -zoom -really-quiet -fs -noconsolecontrols";
    }
    if (!defined($conf->{'BackdropTextColour'})) {
        $conf->{'BackdropTextColour'} = "";
    }
    return $conf;
    if (!defined($conf->{'BackdropShadowColour'})) {
        $conf->{'BackdropShadowColour'} = "";
    }
    $conf->{'DefaultBackdropTextColour'}   = $conf->{'BackdropTextColour'};
    $conf->{'DefaultBackdropShadowColour'} = $conf->{'BackdropShadowColour'};
    return $conf;
}

sub set_maintext {
    my ($text, $transition, $wrap) = @_;
    if (!defined $text) { $text = " "; }
    $text = fromutf($text);

    if ($globals->{'server_type'} == SIMPLE) {
        set_maintext_simple($text, $transition, $wrap);
    } elsif ($globals->{'server_type'} == CLUTTER) {
        set_maintext_clutter($text, $transition, $wrap);
    } else {
        set_maintext_canvas($text, $transition, $wrap);
    }
}

sub set_maintext_clutter {
    my ($text, $transition, $wrap) = @_;
    debug("Setting maintext -clutter");
    if (defined $globals->{'maintext_old'}) {
        $globals->{'maintext_old'}->destroy();
        undef $globals->{'maintext_old'};
    }
    if (!defined $transition) { $transition = 0; }

    # Set the transition values
    my $old_direction = mod($transition, 2**NUM_TRANS);
    $transition = $transition >> NUM_TRANS;
    my $new_direction = mod($transition, 2**NUM_TRANS);
    my $effect = $transition >> NUM_TRANS;

    $globals->{'maintext_old'} = $globals->{'maintext'};
    undef $globals->{'maintext'};
    $globals->{'maintext'} =
      create_outlined_text($text, $config->{'Main'}, $config->{'Colour'},
        $config->{'ShadowColour'});
    my $final_x = $globals->{'stage'}->get_width() / 2;
    my $final_y = $globals->{'stage'}->get_height() / 2;
    if ($config->{'VerticalLocation'} =~ /^T/) {
        if ($globals->{'header'}) {
            $final_y =
              $globals->{'header'}->get_height() +
              ($globals->{'maintext'}->get_height / 2);
        } else {
            $final_y = $globals->{'maintext'}->get_height / 2;
        }
    } elsif ($config->{'VerticalLocation'} =~ /^B/) {
        if ($globals->{'footer'}) {
            $final_y =
              $globals->{'stage'}->get_height() -
              ($globals->{'maintext'}->get_height / 2) -
              $globals->{'footer'}->get_height();
        } else {
            $final_y =
              $globals->{'stage'}->get_height() -
              ($globals->{'maintext'}->get_height / 2);
        }
    }
    if ($config->{'HorizontalLocation'} =~ /^L/) {
        $final_x = $globals->{'maintext'}->get_width / 2;
    } elsif ($config->{'HorizontalLocation'} =~ /^R/) {
        $final_x =
          $globals->{'stage'}->get_width() -
          $globals->{'maintext'}->get_width / 2;
    }
    $globals->{'maintext'}->set_position($final_x, $final_y);

    $globals->{'timeline'} = Clutter::Timeline->new_for_duration(100);
    $globals->{'timeline'}->set_speed(15);
    $globals->{'timeline'}->set_loop(0);
    my $alpha =
      Clutter::Alpha->new($globals->{'timeline'}, \&Clutter::Alpha::ramp_inc);

    # Set start position
    $globals->{'timeline'}->signal_connect(
        'started' => sub {
            if ($effect == NORMAL) {
                $globals->{'maintext'}->set_opacity(0);
            }
            if ($effect == ROTATE) {
                if ($new_direction & X_AXIS) {
                    $globals->{'maintext'}->set_rotation('x-axis', 90, 0, 0, 0);
                }
                if ($new_direction & Y_AXIS) {
                    $globals->{'maintext'}->set_rotation('y-axis', 90, 0, 0, 0);
                }
                if ($new_direction & Z_AXIS) {
                    $globals->{'maintext'}
                      ->set_rotation('z-axis', 180, 0, 0, 0);
                }
            }
            if ($effect == SLIDE_TEXT) {
                my $x = $globals->{'stage'}->get_width() / 2;
                my $y = $globals->{'stage'}->get_height() / 2;
                if ($new_direction & UP) {
                    $y = $globals->{'stage'}->get_height();
                } elsif ($new_direction & DOWN) {
                    $y = 0;
                }
                if ($new_direction & LEFT) {
                    $x = $globals->{'stage'}->get_width();
                } elsif ($new_direction & RIGHT) {
                    $x = 0;
                }

                $globals->{'maintext'}->set_position($x, $y);
            }
            $globals->{'stage'}->add($globals->{'maintext'});
        }
    );

    # Animation
    $globals->{'timeline'}->signal_connect(
        'new-frame' => sub {
            my ($self, $alpha_value) = @_;
            if ($effect == NORMAL) {
                $globals->{'maintext'}->set_opacity($self->get_progress * 255);
                if (defined $globals->{'maintext_old'}) {
                    $globals->{'maintext_old'}
                      ->set_opacity(255 - ($self->get_progress * 255));
                }
            }
            if ($effect == ROTATE) {
                my $rotation = 90 - ($self->get_progress * 90);

                # New item
                if ($new_direction & X_AXIS) {
                    $globals->{'maintext'}
                      ->set_rotation('x-axis', $rotation, 0, 0, 0);
                }
                if ($new_direction & Y_AXIS) {
                    $globals->{'maintext'}
                      ->set_rotation('y-axis', $rotation, 0, 0, 0);
                }
                if ($new_direction & Z_AXIS) {
                    $globals->{'maintext'}
                      ->set_rotation('z-axis', $rotation * 2, 0, 0, 0);
                }
                if (defined $globals->{'maintext_old'}) {

                    # Old item
                    $rotation = 90 - $rotation;
                    if ($new_direction & X_AXIS) {
                        $globals->{'maintext_old'}
                          ->set_rotation('x-axis', $rotation, 0, 0, 0);
                    }
                    if ($new_direction & Y_AXIS) {
                        $globals->{'maintext_old'}
                          ->set_rotation('y-axis', $rotation, 0, 0, 0);
                    }
                    if ($new_direction & Z_AXIS) {
                        $globals->{'maintext_old'}
                          ->set_rotation('z-axis', $rotation * 2, 0, 0, 0);
                    }
                }
            }
            if ($effect == SLIDE_TEXT) {

                # New item
                my $x_start = $globals->{'stage'}->get_width() / 2;
                my $y_start = $globals->{'stage'}->get_height() / 2;
                my $x_end   = $final_x;
                my $y_end   = $final_y;
                if ($new_direction & UP) {
                    $y_start = $globals->{'stage'}->get_height();
                } elsif ($new_direction & DOWN) {
                    $y_start = 0;
                }
                if ($new_direction & LEFT) {
                    $x_start = $globals->{'stage'}->get_width();
                } elsif ($new_direction & RIGHT) {
                    $x_start = 0;
                }
                my $step  = 1 - $self->get_progress;
                my $x_now = (($x_start - $x_end) * $step) + $x_end;
                my $y_now = (($y_start - $y_end) * $step) + $y_end;
                $globals->{'maintext'}->set_position($x_now, $y_now);

                # New item
                $x_start = $globals->{'stage'}->get_width() / 2;
                $y_start = $globals->{'stage'}->get_height() / 2;
                $x_end   = $final_x;
                $y_end   = $final_y;
                if ($old_direction & UP) {
                    $y_end = $globals->{'stage'}->get_height();
                } elsif ($old_direction & DOWN) {
                    $y_end = 0;
                }
                if ($old_direction & LEFT) {
                    $x_end = $globals->{'stage'}->get_width();
                } elsif ($old_direction & RIGHT) {
                    $x_end = 0;
                }
                my $step  = 1 - $self->get_progress;
                my $x_now = (($x_start - $x_end) * $step) + $x_end;
                my $y_now = (($y_start - $y_end) * $step) + $y_end;
                $globals->{'maintext_old'}->set_position($x_now, $y_now);
            }
        }
    );

    # Ensure that text is in final position
    $globals->{'timeline'}->signal_connect(
        'completed' => sub {
            if (defined $globals->{'maintext_old'}) {
                $globals->{'maintext_old'}->remove_all;
                $globals->{'maintext_old'}->destroy();
                undef $globals->{'maintext_old'};
            }
            $globals->{'maintext'}->set_rotation('y-axis', 0, 0, 0, 0);
            $globals->{'maintext'}->set_position($final_x, $final_y);
            $globals->{'maintext'}->set_opacity(255);
            undef $globals->{'timeline'};
        }
    );
    $globals->{'timeline'}->start();
}

sub create_outlined_text {
    my ($text, $font, $text_colour, $shadow_colour) = @_;
    my $group = Clutter::Group->new;
    $text =~ s/\&/\&amp\;/g;

    foreach my $count (0, 2, 10, 12, 18, 24, 6) {
        my $colour;
        if ($count == 6) {
            $colour = Clutter::Color->parse($text_colour);
        } else {
            $colour = Clutter::Color->parse($shadow_colour);
            $colour->alpha(0xA0);
        }
        my $item = Clutter::Label->new($font, $text, $colour);
        if ($config->{'Justification'} =~ /^L/) {
            $item->set_alignment('left');
        } elsif ($config->{'Justification'} =~ /^R/) {
            $item->set_alignment('right');
        } else {
            $item->set_alignment('center');
        }
        $item->set_use_markup(1);
        if ($item->get_width() > $config->{'Width'}) {
            $item->set_line_wrap(1);

            #$item->set_size($globals->{'stage'}->get_width(), -1);
            $item->set_size($config->{'Width'}, -1);
        }
        $item->set_anchor_point($item->get_width() / 2,
            $item->get_height() / 2);
        $item->set_position(($count % 5) - 1, (int($count / 5) - 1));
        $group->add($item);
    }
    $group->set_scale(1 / $MINISCALE, 1 / $MINISCALE);
    return $group;
}

sub set_maintext_simple {
    my ($text, $transition, $wrap) = @_;
    debug("Set maintext simple");
    my $font_desc =
      Gtk2::Pango::FontDescription->from_string($config->{'Main'});
    my $colour = Gtk2::Gdk::Color->parse($config->{'Colour'});
    if ($config->{'BackdropTextColour'} ne "") {
        $colour = Gtk2::Gdk::Color->parse($config->{'BackdropTextColour'});
    }
    $globals->{'mainText'}->modify_fg('normal', $colour);
    $globals->{'mainText'}->modify_font($font_desc);
    $globals->{'mainText'}->set_text($text);
    $globals->{'mainText'}->set_line_wrap($wrap);

    if ($wrap) {
        $globals->{'mainText'}
          ->set_size_request($config->{'Width'} - ($config->{'OverscanH'} * 2),
            -1);
    }
}

sub set_maintext_canvas {
    my ($text, $transition, $wrap) = @_;
    debug("Set maintext canvas");
    my ($oldText);
    if (!defined $transition) { $transition = 0; }

    # Set the transition values
    my $old_direction = mod($transition, 2**NUM_TRANS);
    $transition = $transition >> NUM_TRANS;
    my $new_direction = mod($transition, 2**NUM_TRANS);
    my $effect = $transition >> NUM_TRANS;

    # Copy the old mainText to oldText
    $oldText = $globals->{'mainText'};

    my $top_y = 0;
    if ($config->{'VerticalLocation'} =~ /^T/) {
        $top_y = $headerHeight;
    } elsif ($config->{'VerticalLocation'} =~ /^B/) {
        $top_y = $config->{'Height'};
    } else {
        $top_y = ($config->{'Height'} - $config->{'ShadowSize'}) / 2;
    }

    # Create a new mainText;
    $globals->{'mainText'} = Gnome2::Canvas::Item->new(
        $globals->{'root'}, 'Gnome2::Canvas::RichText',
        x      => ($config->{'Width'} - $config->{'ShadowSize'}) / 2,
        y      => $top_y,
        anchor => 'GTK_ANCHOR_CENTER',
        width  => $config->{'Width'} -
          ($config->{'OverscanH'} * 2) -
          $config->{'ShadowSize'},
        height => $config->{'Height'} -
          $globals->{'headhigh'} -
          ($config->{'OverscanV'} * 2) -
          $config->{'ShadowSize'},
        'cursor-visible' => FALSE
    );
    $globals->{'mainText'}->show();
    my $buffer = $globals->{'mainText'}->get_buffer();
    my $colour = $config->{'Colour'};
    my $tag;
    if ($config->{'BackdropTextColour'} ne "") {
        $colour = $config->{'BackdropTextColour'};
    }
    my $tag = $buffer->create_tag(
        "Main",  "font",      $config->{'Main'}, "foreground",
        $colour, "wrap-mode", "word",            "editable-set",
        TRUE,    "editable",  FALSE
    );
    $buffer->apply_tag_by_name("Main", $buffer->get_bounds);

    # Hide the shadow during the transition
    if ($globals->{'mainTextShadow'}) { $globals->{'mainTextShadow'}->hide(); }
    my $widget = Gtk2::Label->new();
    my $layout = $widget->create_pango_layout("");
    $layout->set_wrap('word');
    $layout->set_width(
        (
            $config->{'Width'} -
              ($config->{'OverscanH'} * 2) -
              $config->{'ShadowSize'}
        ) * PANGO_SCALE
    );
    my $desc = Gtk2::Pango::FontDescription->from_string($config->{'Main'});

    # Find old/new dimensions
    $layout->set_font_description($desc);
    $layout->set_text($oldText->get_buffer()
          ->get_text($oldText->get_buffer()->get_bounds, FALSE));
    my ($ow, $oh) = $layout->get_pixel_size;
    $ow = $ow + 10;
    $oh = $oh + 10;
    $layout->set_text($text);
    my ($w, $h) = $layout->get_pixel_size;
    $w = $w + 10;
    $h = $h + 10;
    my $centreX = $config->{'Width'} / 2;
    my $centreY = $config->{'Height'} / 2;

    if ($config->{'VerticalLocation'} =~ /^B/) {
        $centreY = ($config->{'Height'} - ($h / 2)) - $headerHeight;
    } elsif ($config->{'VerticalLocation'} =~ /^T/) {
        $centreY = ($h / 2) + $headerHeight;
    }

    my @items = ();
    if ($effect == SLIDE_TEXT) {
        my $ostepx = 0;
        my $ostepy = 0;
        my $nstepx = 0;
        my $nstepy = 0;
        my $nx     = $centreX;
        my $ny     = $centreY;
        if ($oldText->get_buffer()
            ->get_text($oldText->get_buffer()->get_bounds, FALSE) eq "")
        {
            $old_direction = WAIT;
        }
        if ($old_direction & RIGHT) {
            $ostepx = (($config->{'Width'} + ($ow / 2)) - $centreX) / $steps;
        }
        if ($old_direction & LEFT) {
            $ostepx = -(($config->{'Width'} + ($ow / 2)) - $centreX) / $steps;
        }
        if ($old_direction & UP) {
            $ostepy = (($config->{'Height'} + ($oh / 2)) - $centreY) / $steps;
        }
        if ($old_direction & DOWN) {
            $ostepy = -(($config->{'Height'} + ($oh / 2)) - $centreY) / $steps;
        }
        if ($new_direction & RIGHT) {
            $nx = -($w / 2);
            $nstepx = (($config->{'Width'} + ($w / 2)) - $centreX) / $steps;
        }
        if ($new_direction & LEFT) {
            $nx = $config->{'Width'} + ($w / 2);
            $nstepx = -(($config->{'Width'} + ($w / 2)) - $centreX) / $steps;
        }
        if ($new_direction & UP) {
            $ny = $config->{'Height'} + ($h / 2);
            $nstepy = -(($config->{'Height'} + ($h / 2)) - $centreY) / $steps;
        }
        if ($new_direction & DOWN) {
            $ny = -($h / 2);
            $nstepy = (($config->{'Height'} + ($h / 2)) - $centreY) / $steps;
        }
        my $ox = $centreX;
        my $oy = $centreY;
        $buffer->set_text($text);
        $buffer->apply_tag_by_name("Main", $buffer->get_bounds);
        $globals->{'mainText'}->set(width => $w,  height => $h);
        $globals->{'mainText'}->set(x     => $nx, y      => $ny);
        $globals->{'mainText'}->set_buffer($buffer);

        if (!(($old_direction & WAIT) && ($new_direction & WAIT))) {
            foreach my $step (1 .. $steps) {
                if (!($old_direction & WAIT)) {
                    $oldText->set(x => ($ox + ($step * $ostepx)));
                    $oldText->set(y => ($oy + ($step * $ostepy)));
                }
                if (!($new_direction & WAIT)) {
                    $globals->{'mainText'}->set(x => ($nx + ($step * $nstepx)));
                    $globals->{'mainText'}->set(y => ($ny + ($step * $nstepy)));
                }
                select(undef, undef, undef, 0.01);
                do_pending();
            }
        }
        if (($old_direction & WAIT) || ($new_direction & WAIT)) {
            foreach my $step (1 .. $steps) {
                if ($old_direction & WAIT) {
                    $oldText->set(x => ($ox + ($step * $ostepx)));
                    $oldText->set(y => ($oy + ($step * $ostepy)));
                }
                if ($new_direction & WAIT) {
                    $globals->{'mainText'}->set(x => ($nx + ($step * $nstepx)));
                    $globals->{'mainText'}->set(y => ($ny + ($step * $nstepy)));
                }
                select(undef, undef, undef, 0.01);
                do_pending();
            }
        }
    } elsif ($effect == WIPE) {
        $items[0] = Gnome2::Canvas::Item->new(
            $globals->{'root'},
            'Gnome2::Canvas::Rect',
            y1         => ($config->{'Height'} - $oh) / 2,
            y2         => ($config->{'Height'} + $oh) / 2,
            x1         => ($config->{'Width'} - $ow) / 2,
            x2         => ($config->{'Width'} - $ow) / 2,
            fill_color => 'black'
        );
        my $stepsize = $ow / 20;
        for (
            my $fx = ($config->{'Width'} - $ow) / 2 ;
            $fx < ($config->{'Width'} + $ow) / 2 ;
            $fx = $fx + $stepsize
          )
        {
            $items[0]->set(x2 => $fx);
            select(undef, undef, undef, 0.01);
            do_pending();
        }
        $buffer->set_text($text);
        $buffer->apply_tag_by_name("Main", $buffer->get_bounds);
        $globals->{'mainText'}->set(width => $w, height => $h);
        $globals->{'mainText'}->set_buffer($buffer);
        $items[0]->set(
            y1 => ($config->{'Height'} - $h) / 2,
            x1 => ($config->{'Width'} - $w) / 2,
            x2 => ($config->{'Width'} + $w) / 2,
            y2 => ($config->{'Height'} + $h) / 2
        );
        $stepsize = $w / 20;
        for (
            my $fx = ($config->{'Width'} - $w) / 2 ;
            $fx < ($config->{'Width'} + $w) / 2 ;
            $fx = $fx + $stepsize
          )
        {
            $items[0]->set(x1 => $fx);
            select(undef, undef, undef, 0.01);
            do_pending();
        }
        $items[0]->destroy;
    } else {
        $buffer->set_text($text);
        $buffer->apply_tag_by_name("Main", $buffer->get_bounds);
        $globals->{'mainText'}->set(width => $w, height => $h);
        $globals->{'mainText'}
          ->set(x => $centreX - ($config->{'ShadowSize'} / 2));
        $globals->{'mainText'}
          ->set(y => $centreY - ($config->{'ShadowSize'} / 2));
        $globals->{'mainText'}->set_buffer($buffer);
    }
    $oldText->destroy;

    # Make sure text in right spot
    $buffer->set_text($text);
    $buffer->apply_tag_by_name("Main", $buffer->get_bounds);
    $globals->{'mainText'}->set(
        x => $centreX - ($config->{'ShadowSize'} / 2),
        y => $centreY - ($config->{'ShadowSize'} / 2),
        width  => $w,
        height => $h,
    );
    $globals->{'mainText'}->set_buffer($buffer);
    $globals->{'mainText'}->show();

    if ($MINISERV < 0) {

        # Add the shadow
        $globals->{'mainTextShadow'} = Gnome2::Canvas::Item->new(
            $globals->{'root'}, 'Gnome2::Canvas::RichText',
            x => $centreX + ($config->{'ShadowSize'} / 2),
            y => $centreY + ($config->{'ShadowSize'} / 2),
            width            => $w,
            height           => $h,
            anchor           => 'GTK_ANCHOR_CENTER',
            'cursor-visible' => FALSE
        );
        my $buffer2      = $globals->{'mainTextShadow'}->get_buffer();
        my $shadowcolour = $config->{'ShadowColour'};
        if ($config->{'BackdropShadowColour'} ne "") {
            $shadowcolour = $config->{'BackdropShadowColour'};
        }
        my $tags = $buffer2->create_tag(
            "MainShadow",      "font",
            $config->{'Main'}, "foreground",
            $shadowcolour,     "wrap-mode",
            "word",            "editable-set",
            TRUE,              "editable",
            FALSE
        );
        $buffer2->set_text($text);
        $buffer2->apply_tag_by_name("MainShadow", $buffer2->get_bounds);
        $globals->{'mainTextShadow'}->set_buffer($buffer2);
        $globals->{'mainText'}->raise_to_top();
        $globals->{'mainTextShadow'}->show();
    }
}

sub Configure_event {

#my ($width, $height) = $globals->{'window'}->get_size();
#$MINISCALE = $config->{'Width'} / $width;
#if (!$globals->{'fast'}) {
#    if ($globals->{'canvas'}) {
#        $globals->{'canvas'}->set_pixels_per_unit(1 / $MINISCALE);
#    }
#}
#$globals->{'window'}->set_size_request($width, $config->{'Height'} / $MINISCALE);

    #debug($width . "x" . ($config->{'Height'} / $MINISCALE));
    #debug("Scale: " . $MINISCALE);
}

sub display_fatal {
    my ($message, $error) = @_;
    print STDERR "\n\n-------------\n";
    print STDERR "FATAL ERROR!!\n";
    print STDERR "-------------\n";
    print STDERR "Error description\n";
    print STDERR $message . "\n";
    print STDERR "------------------\n";

    # Don't want this to show up on projector
    #my $errorxml =
    #  Gtk2::GladeXML->new($globals->{'gladefile'}, 'dialogError', 'lyricue');
    #$errorxml->signal_autoconnect_from_package('');
    #$errorxml->get_widget('labelError')->set_text($message);
    #my $confirm = $errorxml->get_widget('dialogError')->run();
    #close_dialog($errorxml->get_widget('dialogError'));
    print STDERR "Full error message\n";
    print STDERR "------------------\n";
    die($error);
}

sub close_dialog {
    my ($widget) = @_;
    debug("Close dialog");
    $widget->get_toplevel->destroy;
}

sub mod {
    my ($inp, $div) = @_;
    my $rem = (($inp / $div) - (int($inp / $div))) * $div;
    return $rem;
}

sub set_footer {
    my ($text) = @_;
    if (!defined $text) { $text = " "; }
    $text = fromutf($text);
    if ($globals->{'server_type'} == SIMPLE) {
        set_footer_simple($text);
    } elsif ($globals->{'server_type'} == CLUTTER) {
        set_footer_clutter($text);
    } else {
        set_footer_canvas($text);
    }
}

sub set_footer_clutter {
    my ($text) = @_;
    if (defined $globals->{'footer'}) {
        $globals->{'footer'}->destroy;
        undef $globals->{'footer'};
    }
    if ($text eq "") {
        return;
    }
    $globals->{'footer'} =
      create_outlined_text($text, $config->{'Footer'}, $config->{'Colour'},
        $config->{'ShadowColour'});
    $globals->{'footer'}->set_position(
        $globals->{'stage'}->get_width() / 2,
        $globals->{'stage'}->get_height() / 2
    );
    $globals->{'stage'}->add($globals->{'footer'});
    $globals->{'footer'}->set_position(
        $globals->{'stage'}->get_width() / 2,
        $globals->{'stage'}->get_height() -
          ($globals->{'footer'}->get_height() / 2)
    );
}

sub set_footer_simple {
    my ($text) = @_;
    my $font_desc =
      Gtk2::Pango::FontDescription->from_string($config->{'Footer'});
    $globals->{'footerText'}->modify_font($font_desc);
    my $colour = Gtk2::Gdk::Color->parse($config->{'Colour'});
    if ($config->{'BackdropTextColour'} ne "") {
        $colour = Gtk2::Gdk::Color->parse($config->{'BackdropTextColour'});
    }
    $globals->{'footerText'}->modify_fg('normal', $colour);
    $globals->{'footerText'}->set_text($text);
}

sub set_footer_canvas {
    my ($text) = @_;
    my $widget = Gtk2::Label->new();
    my $layout = $widget->create_pango_layout("");
    $layout->set_wrap('word');
    $layout->set_width(
        (
            $config->{'Width'} -
              ($config->{'OverscanH'} * 2) -
              $config->{'ShadowSize'}
        ) * PANGO_SCALE
    );
    my $desc = Gtk2::Pango::FontDescription->from_string($config->{'Footer'});
    $layout->set_font_description($desc);
    $layout->set_text($text);
    my ($w, $h) = $layout->get_pixel_size;
    $w = $w + 10;
    $h = $h + 10;
    if ($globals->{'footerText'}) { $globals->{'footerText'}->destroy(); }
    $globals->{'footerText'} = Gnome2::Canvas::Item->new(
        $globals->{'root'}, 'Gnome2::Canvas::RichText',
        x                => $config->{'Width'} / 2,
        y                => $config->{'Height'} - $config->{'OverscanV'},
        anchor           => 'GTK_ANCHOR_S',
        width            => $w,
        height           => $h,
        'cursor-visible' => FALSE
    );
    my $buffer = $globals->{'footerText'}->get_buffer();
    my $colour = $config->{'Colour'};

    if ($config->{'BackdropTextColour'} ne "") {
        $colour = $config->{'BackdropTextColour'};
    }
    my $tag3 = $buffer->create_tag(
        "Footer",            "font",
        $config->{'Footer'}, "foreground",
        $colour,             "wrap-mode",
        "word",              "editable-set",
        TRUE,                "editable",
        FALSE
    );
    $buffer->set_text($text);
    $buffer->apply_tag_by_name("Footer", $buffer->get_bounds);
}

sub set_header {
    my ($text) = @_;
    if (!defined $text) { $text = " "; }
    $text = fromutf($text);
    if ($globals->{'server_type'} == SIMPLE) {
        set_header_simple($text);
    } elsif ($globals->{'server_type'} == CLUTTER) {
        set_header_clutter($text);
    } else {
        set_header_canvas($text);
    }
}

sub set_header_clutter {
    my ($text) = @_;
    debug("Setting header");
    if (defined $globals->{'header'}) {
        $globals->{'header'}->destroy();
        undef $globals->{'header'};
    }
    if ($text eq "") {
        return;
    }

    $globals->{'header'} =
      create_outlined_text($text, $config->{'Header'}, $config->{'Colour'},
        $config->{'ShadowColour'});
    $globals->{'header'}->set_position(
        $globals->{'stage'}->get_width() / 2,
        $globals->{'stage'}->get_height() / 2
    );
    $globals->{'stage'}->add($globals->{'header'});
    $globals->{'header'}->set_position(
        $globals->{'stage'}->get_width() / 2,
        $globals->{'header'}->get_height() / 2
    );
}

sub set_header_simple {
    my ($text) = @_;
    my $font_desc =
      Gtk2::Pango::FontDescription->from_string($config->{'Header'});
    $globals->{'headerText'}->modify_font($font_desc);
    my $colour = Gtk2::Gdk::Color->parse($config->{'Colour'});
    if ($config->{'BackdropTextColour'} ne "") {
        $colour = Gtk2::Gdk::Color->parse($config->{'BackdropTextColour'});
    }
    $globals->{'headerText'}->modify_fg('normal', $colour);
    $globals->{'headerText'}->set_text($text);
}

sub set_header_canvas {
    my ($text) = @_;

    my $widget = Gtk2::Label->new();
    my $layout = $widget->create_pango_layout("");
    $layout->set_wrap('word');
    $layout->set_width(
        (
            $config->{'Width'} -
              ($config->{'OverscanH'} * 2) -
              $config->{'ShadowSize'}
        ) * PANGO_SCALE
    );
    my $desc = Gtk2::Pango::FontDescription->from_string($config->{'Header'});
    $layout->set_font_description($desc);
    $layout->set_text($text);
    my ($w, $h) = $layout->get_pixel_size;
    $w            = $w + 10;
    $h            = $h + 10;
    $headerHeight = $h;
    if ($globals->{'headerText'}) { $globals->{'headerText'}->destroy(); }
    $globals->{'headerText'} = Gnome2::Canvas::Item->new(
        $globals->{'root'}, 'Gnome2::Canvas::RichText',
        x                => $config->{'Width'} / 2,
        y                => $config->{'OverscanV'},
        anchor           => 'GTK_ANCHOR_N',
        width            => $w,
        height           => $h,
        'cursor-visible' => FALSE
    );
    my $buffer = $globals->{'headerText'}->get_buffer();
    my $colour = $config->{'Colour'};

    if ($config->{'BackdropTextColour'} ne "") {
        $colour = $config->{'BackdropTextColour'};
    }
    my $tag3 = $buffer->create_tag(
        "Header",            "font",
        $config->{'Header'}, "foreground",
        $colour,             "wrap-mode",
        "word",              "editable-set",
        TRUE,                "editable",
        FALSE
    );
    $buffer->set_text($text);
    $buffer->apply_tag_by_name("Header", $buffer->get_bounds);
}

sub get_bibles {
    my $bibles;
    debug("Getting available bibles");

    # Bible databases found
    my $dbs = $globals->{'db_available_db'};
    foreach (keys %$dbs) {
        my $dbname = $_;
        my $db     = db_connect($dbname, "");
        my @tables = $db->tables;
        my $table;
        foreach (@tables) {
            $_ =~ s/^.*`(.*)`$/$1/g;
            $_ =~ s/^"(.*)"$/$1/g;
            if (/^verse$/) {
                my $query = "SELECT * FROM verse WHERE book=\"Bible\";";
                qdebug($query);
                my $sth = $db->prepare($query)
                  || display_fatal($errorcodes->{'sqlprepare'}, $!);
                my $rv = $sth->execute
                  || display_fatal($errorcodes->{'sqlexecute'}, $!);
                my $row = $sth->fetchrow_hashref();
                if (defined $row->{'verse'}) {
                    $bibles->{$dbname} = "db;" . $row->{'verse'};
                }
                $sth->finish;
            }
        }
        $db->disconnect();
    }

#    open(CONFIG, $globals->{'configfile'})
#      || display_fatal($errorcodes->{'fileopenread'} . $globals->{'configfile'},
#        $!);
#    while (<CONFIG>) {
#        chomp;
#        my @line = split(/=/);
#        $line[0] =~ s/ *$//g;
#        $line[1] =~ s/ *$//g;
#        $line[1] =~ s/^ *//g;
#        my @line2 = split(/;/, $line[1], 2);
#        if ($line[0] eq "Bible") {
#            $bibles->{$line2[1]} = "db;" . $line2[0];
#print $line2[0]."---".$line2[1]."\n";
#        }
#    }

    # Bibles provided by Sword libraries
    if ($^O ne 'MSWin32') {
        my $command = $globals->{'diatheke'} . " -b system -k modulelist|";
        debug($command);
        open(SWORD, $command);
        while (<SWORD>) {
            if (/^Biblical Texts:/) {
                while (<SWORD>) {
                    if (/^Commentaries:/) {
                        while (<SWORD>) { }
                    } else {
                        chomp;
                        my @bible = split(/:/, $_, 2);
                        $bible[0] =~ s/\s+$//;
                        $bible[1] =~ s/^\s+//;
                        $bibles->{$bible[0]} = "sword;" . $bible[1];
                    }
                }
            }
        }
        close SWORD;
    }
    return $bibles;
}

sub update_snapshot {
    debug("Updating snapshot");

    #if ($globals->{'preview'}) {

    if (   ($globals->{'server_type'} == CANVAS)
        || ($globals->{'server_type'} == SIMPLE))
    {
        my $window = $globals->{'window'}->window();
        my $pixmap =
          Gtk2::Gdk::Pixbuf->get_from_drawable($window, $window->get_colormap(),
            0, 0, 0, 0, $window->get_size());
        $pixmap->scale_simple(320, 240, 'nearest')
          ->save("/tmp/lyricue.png", "png");
        $globals->{'snapshot_changed'} = TRUE;
    } else {
        my $command =
          "import -silent -window root -resize 200x150 /tmp/lyricue_"
          . $globals->{'use_port'} . ".png";
        `$command`;
        $globals->{'snapshot_changed'} = TRUE;
    }

    #}
    reset_timer($globals->{'snapshot_timer'});
}

sub reset_timer {
    my ($timer) = @_;
    if ($timer) {
        debug("Cancelling timer");
        Glib::Source->remove($timer);
        $timer = FALSE;
    }
}

sub create_window {
    my ($pixmap, $textcol);

    if ($MINISERV > 0) {
        $globals->{'window'} = Gtk2::Plug->new($MINISERV);
    } else {
        $globals->{'window'} = Gtk2::Window->new('toplevel');
    }
    $globals->{'window'}->set_title("Lyric Server");

    do_pending();

    $globals->{'window'}->show();
    if ($MINISERV >= 0) {
        $globals->{'window'}->show();
        $globals->{'window'}->realize();
        my $width  = $config->{'Width'};
        my $height = $config->{'Height'};
        my ($width2, $height2) = $globals->{'window'}->get_size();
        $MINISCALE = $width / $width2;
        $width  /= $MINISCALE;
        $height /= $MINISCALE;

        $globals->{'window'}->resize($width, $height);
        debug("Running in MINISERV (preview window) mode");
        debug("W * H:" . $width . "*" . $height);
    } else {
        if ($globals->{'window_offset'}) { }
        $globals->{'window'}
          ->set_default_size($config->{'Width'}, $config->{'Height'});
        $globals->{'window'}->resize($config->{'Width'}, $config->{'Height'});
        if ($globals->{'run_windowed'} == FALSE) {
            $globals->{'window'}->fullscreen();
        }
        debug("Running in SERVER (normal) mode");
    }
    my $bitmap = Gtk2::Gdk::Bitmap->create_from_data(undef, 0, 1, 1);
    my $cursor = Gtk2::Gdk::Cursor->new_from_pixmap(
        $bitmap, $bitmap,
        Gtk2::Gdk::Color->new(0, 0, 0),
        Gtk2::Gdk::Color->new(0, 0, 0),
        0, 0
    );
    $globals->{'window'}->window->set_cursor($cursor);

    do_pending();

    eval { require Clutter };
    if ($@) {
        print "Optional module Clutter not available. Using canvas server\n";
        $globals->{'server_type'} = CANVAS;
    } else {
        import Clutter;
        import Clutter qw( :gtk-init );
        import Clutter::Keysyms;
    }
    my $aspect = $config->{'Width'} / $config->{'Height'};
    my $geom   = Gtk2::Gdk::Geometry->new;
    $geom->min_aspect($aspect);
    $globals->{'window'}
      ->set_geometry_hints($globals->{'window'}, $geom, 'GDK_HINT_ASPECT');
    eval { require Gnome2::Canvas; };
    if ($@) {
        print
          "Optional module Gnome2::Canvas not available. Using simple server\n";
        $globals->{'server_type'} = SIMPLE;
    } else {
        import Gnome2::Canvas;
    }
    if ($globals->{'server_type'} == SIMPLE) {
        debug("Using simple server");
        my $vbox = Gtk2::VBox->new(FALSE, 0);
        $globals->{'window'}->add($vbox);
        debug("Creating text areas");

        # Create the area for lyrics and set styles
        my $mainStyle   = new Gtk2::Style;
        my $headerStyle = new Gtk2::Style;
        my $footerStyle = new Gtk2::Style;
        $globals->{'headerText'} = Gtk2::Label->new();
        $globals->{'mainText'}   = Gtk2::Label->new();
        $globals->{'footerText'} = Gtk2::Label->new();
        $globals->{'headerText'}->set_line_wrap(TRUE);
        $globals->{'headerText'}
          ->set_size_request($config->{'Width'} - ($config->{'OverscanH'} * 2),
            -1);
        $globals->{'headerText'}->set_justify('center');
        $globals->{'mainText'}->set_line_wrap(TRUE);
        $globals->{'footerText'}->set_line_wrap(TRUE);
        $globals->{'footerText'}
          ->set_size_request($config->{'Width'} - ($config->{'OverscanH'} * 2),
            -1);
        $globals->{'footerText'}->set_justify('center');

        if ($config->{'VerticalLocation'} =~ /^B/) {
            my $fill = Gtk2::Label->new();
            $vbox->pack_start($fill,                    TRUE,  TRUE,  0);
            $vbox->pack_start($globals->{'headerText'}, FALSE, FALSE, 0);
            $vbox->pack_start($globals->{'mainText'},   FALSE, TRUE,  0);
        } elsif ($config->{'VerticalLocation'} =~ /^C/) {
            $vbox->pack_start($globals->{'headerText'}, FALSE, FALSE, 0);
            $vbox->pack_start($globals->{'mainText'},   TRUE,  TRUE,  0);
        } else {
            $vbox->pack_start($globals->{'headerText'}, FALSE, FALSE, 0);
            $vbox->pack_start($globals->{'mainText'},   FALSE, TRUE,  0);
            my $fill = Gtk2::Label->new();
            $vbox->pack_start($fill, TRUE, TRUE, 0);
        }
        $vbox->pack_start($globals->{'footerText'}, FALSE, FALSE, 0);
    } elsif ($globals->{'server_type'} == CLUTTER) {
        debug("Using clutter server");
        Clutter::Threads->init();
        Clutter->init();
        Clutter::Gst->init;
        my $black_colour = Clutter::Color->new(0, 0, 0, 0xff);
        my $embed = Gtk2::ClutterEmbed->new();
        $globals->{'window'}->add($embed);
        $globals->{'stage'} = $embed->get_stage();
        $globals->{'stage'}->set_color($black_colour);
        $globals->{'stage'}->hide_cursor();
    } else {
        debug("Using full server");
        $globals->{'canvas'} = Gnome2::Canvas->new();
        $globals->{'canvas'}
          ->signal_connect("button_press_event", \&HandleMouse);
        $globals->{'canvas'}
          ->set_scroll_region(0, 0, $config->{'Width'}, $config->{'Height'});
        $globals->{'canvas'}->set_center_scroll_region(TRUE);
        $globals->{'canvas'}->set_pixels_per_unit(1 / $MINISCALE);

        $globals->{'window'}->add($globals->{'canvas'});
        $globals->{'root'} = $globals->{'canvas'}->root;
        $globals->{'canvas'}->show();

        $background_black = Gnome2::Canvas::Item->new(
            $globals->{'root'},
            'Gnome2::Canvas::Rect',
            x1            => 0,
            y1            => 0,
            x2            => $config->{'Width'},
            y2            => $config->{'Height'},
            fill_color    => 'black',
            outline_color => 'black'
        );

        # Find font sizes
        my $layout = $globals->{'window'}->create_pango_layout("lj");
        my $tmpdesc =
          Gtk2::Pango::FontDescription->from_string($config->{'Header'});
        $layout->set_font_description($tmpdesc);
        ($globals->{'headhigh'}, $globals->{'headwide'}) =
          $layout->get_pixel_size;

        debug("Creating text areas");

        # Create the area for lyrics and set styles
        # Song lyrics - Middle of screen
        $globals->{'mainText'} = Gnome2::Canvas::Item->new(
            $globals->{'root'}, 'Gnome2::Canvas::RichText',
            x                => 0,
            y                => 0,
            width            => 0,
            height           => 0,
            anchor           => 'GTK_ANCHOR_CENTER',
            'cursor-visible' => FALSE
        );
        my $buffer = $globals->{'mainText'}->get_buffer();
        my $colour = $config->{'Colour'};
        if ($config->{'BackdropTextColour'} ne "") {
            $colour = $config->{'BackdropTextColour'};
        }
        my $tag2 = $buffer->create_tag(
            "Main",            "font",
            $config->{'Main'}, "foreground",
            $colour,           "wrap-mode",
            "word",            "editable-set",
            TRUE,              "editable",
            FALSE
        );
        $buffer->apply_tag_by_name("Main", $buffer->get_bounds);
    }

    # callback registration
    $globals->{'window'}->signal_connect("delete_event", \&CloseAppWindow);
    $globals->{'windowid'} = $globals->{'window'}->window->XWINDOW;
    debug("Window ID: " . $globals->{'windowid'});

    $globals->{'window'}->signal_connect("key_press_event", \&HandleKey);
    if ($config->{'ServerMouse'} ne "") {
        $globals->{'window'}
          ->signal_connect("button_press_event", \&HandleMouse);
    }

    # set window attributes and show it
    debug("Showing window");
    $globals->{'window'}->show_all();
    $globals->{'window'}->signal_connect("configure_event", \&Configure_event);
    Configure_event();

    if ($globals->{'server_type'} == CANVAS) {
        $globals->{'canvas'}->update_now();
    }

    debug("Done");
}

sub refresh_screen {
    if ($globals->{'server_type'} != CLUTTER) {
        $globals->{'window'}->show_all();
    }
}

sub do_pending {
    while (Gtk2->events_pending) {
        Gtk2->main_iteration;
    }
}

sub get_playlists {
    my $data = "";
    my $query =
"SELECT title FROM playlists LEFT JOIN playlist ON BINARY playlist.data=playlists.id AND playlist.data NOT LIKE '%-%' WHERE data IS NULL ORDER BY id";
    debug($query);
    my $sth = $lyricDbh->prepare($query)
      || display_fatal($errorcodes->{'sqlprepare'}, $!);
    my $rv = $sth->execute || display_fatal($errorcodes->{'sqlexecute'}, $!);
    my @row;
    while (@row = $sth->fetchrow_array()) {
        $data .= $row[0] . "\n";
    }
    return $data;
}

sub get_playlist {
    my ($playlist, $pre) = @_;
    my $data = "";
    if ($playlist =~ /\D/) {
        my $query =
          "SELECT id FROM playlists WHERE title=\"" . $playlist . "\"";
        my $sth = $lyricDbh->prepare($query)
          || display_fatal($errorcodes->{'sqlprepare'}, $!);
        my $rv = $sth->execute
          || display_fatal($errorcodes->{'sqlexecute'}, $!);
        my $row = $sth->fetchrow_hashref();
        $playlist = $row->{'id'};
    }
    my $query =
        "SELECT * FROM playlist WHERE playlist=\""
      . $playlist
      . "\" ORDER BY playorder";
    debug($query);
    my $sth = $lyricDbh->prepare($query)
      || display_fatal($errorcodes->{'sqlprepare'}, $!);
    my $rv = $sth->execute || display_fatal($errorcodes->{'sqlexecute'}, $!);
    while (my $row = $sth->fetchrow_hashref()) {
        my $title = "";
        if ($row->{'type'} eq "back") {
            my $query2 = "SELECT description FROM media WHERE id=\""
              . $row->{'data'} . "\"";
            debug($query2);
            my $sth2 = $mediaDbh->prepare($query2)
              || display_fatal($errorcodes->{'sqlprepare'}, $!);
            my $rv2 = $sth2->execute
              || display_fatal($errorcodes->{'sqlexecute'}, $!);
            my $row2 = $sth2->fetchrow_hashref();
            $title = "Background : " . $row2->{'description'};
        } elsif ($row->{'type'} eq "file") {
            $title = "File: " . $row->{'data'};
        } elsif ($row->{'type'} eq "imag") {
            my $query2 = "SELECT description FROM media WHERE id=\""
              . $row->{'data'} . "\"";
            my $sth2 = $mediaDbh->prepare($query2)
              || display_fatal($errorcodes->{'sqlprepare'}, $!);
            my $rv2 = $sth2->execute
              || display_fatal($errorcodes->{'sqlexecute'}, $!);
            my $row2 = $sth2->fetchrow_hashref();
            $title = "Image: " . $row2->{'description'};
        } elsif ($row->{'type'} eq "vers") {
            $title = "Verses " . $row->{'data'};
        } elsif ($row->{'type'} eq "song") {
            my $query2 =
              "SELECT lyrics FROM page WHERE pageid=" . $row->{'data'};
            my $sth2 = $lyricDbh->prepare($query2)
              || display_fatal($errorcodes->{'sqlprepare'}, $!);
            my $rv2 = $sth2->execute
              || display_fatal($errorcodes->{'sqlexecute'}, $!);
            my $row2   = $sth2->fetchrow_hashref();
            my $lyrics = $row2->{'lyrics'};
            if ($globals->{'invert'}) {
                my @lyricl = split(/\n/, $lyrics);
                $title = $lyricl[@lyricl - 1];
            } else {
                ($title, undef) = split(/\n/, $lyrics);
            }
            if (!$title) {
                $title = "";
            }
        } elsif ($row->{'type'} eq "play" | $row->{'type'} eq "sub") {

            # Leave this to later
            my $query2 = "SELECT * FROM playlists WHERE id=" . $row->{'data'};
            my $sth2   = $lyricDbh->prepare($query2)
              || display_fatal($errorcodes->{'sqlprepare'}, $!);
            my $rv2 = $sth2->execute
              || display_fatal($errorcodes->{'sqlexecute'}, $!);
            my $row2 = $sth2->fetchrow_hashref();

            $title = $row2->{'title'};

            if ($row2->{'ref'} && $row2->{'ref'} != 0) {
                $query2 =
                  "SELECT songnum FROM lyricMain WHERE id=" . $row2->{'ref'};
                $sth2 = $lyricDbh->prepare($query2)
                  || display_fatal($errorcodes->{'sqlprepare'}, $!);
                $rv2 = $sth2->execute
                  || display_fatal($errorcodes->{'sqlexecute'}, $!);
                $row2 = $sth2->fetchrow_hashref();
                if ($row2->{'songnum'} != 0) {
                    $title = $row2->{'songnum'} . " - " . $title;
                }
            }
        } else {
            $title = "Unknown type";
        }
        $data .= $pre . $row->{'playorder'} . ":" . $title . "\n";

        # Add sublists/playlists
        if ($row->{'type'} eq "play" | $row->{'type'} eq "sub") {
            $data .= get_playlist($row->{'data'}, $pre . "+");
        }
    }

    return $data;
}

sub update_tracker {
    debug("Updating tracker");

    # only do if this is main server
    if ($globals->{'use_port'} == $globals->{'server_port'}) {
        my $item = $current_item;
        if ($globals->{'blanked_state'}) {
            $item = -1;
        }
        my $query = "UPDATE playlists SET ref = " . $item . " WHERE id=-1";
        debug($query);
        my $sth = $lyricDbh->prepare($query)
          || display_fatal($errorcodes->{'sqlprepare'}, $!);
        my $rv = $sth->execute
          || display_fatal($errorcodes->{'sqlexecute'}, $!);
    }
}

sub check_tracker {
    debug("Checking tracker");
    my $query = "SELECT ref FROM playlists WHERE id=-1";
    debug($query);
    my $sth = $lyricDbh->prepare($query)
      || display_fatal($errorcodes->{'sqlprepare'}, $!);
    my $rv = $sth->execute
      || display_fatal($errorcodes->{'sqlexecute'}, $!);
    if ($sth->fetchrow_array()) {
        update_tracker();
    } else {
        $query = "INSERT INTO playlists (id,ref) VALUES (-1,-1)";
        debug($query);
        my $sth = $lyricDbh->prepare($query)
          || display_fatal($errorcodes->{'sqlprepare'}, $!);
        my $rv = $sth->execute
          || display_fatal($errorcodes->{'sqlexecute'}, $!);
    }
}

sub db_check_app {
    debug("Checking for database servers");
    if (defined $globals->{'force_sqlite'} && ($globals->{'force_sqlite'})) {
        debug("Forcing usage of SQLite3");
        $globals->{'db_type'} = "SQLite";
        return;
    }
    if ($config->{'DatabaseType'} eq "SQLite") {
        $globals->{'db_type'} = "SQLite";
        return;
    }
    my @ary    = DBI->available_drivers(1);
    my $mysql  = FALSE;
    my $sqlite = FALSE;
    foreach (@ary) {
        if ($_ eq "mysql") {
            $mysql = TRUE;
        } elsif ($_ eq "SQLite") {
            $sqlite = TRUE;
        }
    }
    if ($mysql) {
        $globals->{'db_type'} = "mysql";
    } elsif ($sqlite) {
        $globals->{'db_type'} = "SQLite";
    } else {
        die("No supported DB found");
    }
}

sub db_connect {
    my ($dbname, $dberror) = @_;
    my ($dbh);
    if ($globals->{'db_type'} eq "SQLite") {
        $dbh =
          DBI->connect("dbi:SQLite:" . $globals->{'basedir'} . $dbname . ".db",
            "", "")
          || display_fatal($dberror, $DBI::errstr);
    } else {
        $dbh = DBI->connect(
            "DBI:" . $globals->{'db_type'} . ":$dbname:$globals->{'host'}",
            "lyric", "")
          || display_fatal($dberror, $DBI::errstr);
    }
    return $dbh;
}

sub HandleMouse {
    my ($widget, $data) = @_;
    debug("Handle Mouse click");
    if ($data->button == 1) {
        update_display("display", "next_page", $config->{'Loop'});
    } elsif ($data->button == 2) {
        update_display("display", "next_song", 0);
    } elsif ($data->button == 3) {
        update_display("display", "prev_page", $config->{'Loop'});
    }
}

sub fromutf {
    my ($line) = @_;
    return Encode::decode("utf8", $line);
}

sub toutf {
    my ($line) = @_;
    return Encode::encode("utf8", $line);
}

