#!/usr/bin/env perl

#****** lyricue_server/pod
# NAME
#   Pod documentation
# DESCRIPTION
#   Documentation for lyricue_server that is displayed by perldoc
# SOURCE
#

=head1 NAME

lyricue_server - Lyricue Server

=head1 SYNOPSIS

lyricue_server [ C<-v|-b> C<-m> C<-d> ]

=head1 DESCRIPTION

This script creates a fullscreen window that is used to display song lyrics (normally on a second screen, projector or similar) OR a scaled server window that can be used to preview songs a given screen.

=head1 OPTIONS

=over 4

=item B<-v>

Get lyricue_server version

=item B<-d>

Turn on debugging mode. Prints out debugging information

=item B<-m>

Run in miniserv mode (used for preview window in interface)


=head1 CONFIGURATION

All configuration is done by editing the configuration section in the program

=head1 REQUIRES

Perl 5.6 or later, DBI::MySQL, Gtk2-Perl, MySql database

=head1 AUTHOR

Chris Debenham <chris@adebenham.com>

=head1 COPYRIGHT

This program is released under the GPL (http://www.gnu.org/copyleft/gpl.html)

=head1 VERSION

Lyricue_server Version 1.9.2

=cut

#***

#****** lyricue_server/setup
# NAME
#   Setup section
# DESCRIPTION
#   Loads required modules, sets some global variables,
#   and other global things
# SOURCE
#

#
# Modules we use.
#
use strict;
use DBI;
use POSIX;
use IO::Socket::INET;    #use Socket;
use Encode;
die "The gtk2-perl bindings could not be initialized; we need them to run!\n"
  unless (Gtk2->init_check);
use Gtk2::Pango;
use Gtk2::GladeXML;
use Gtk2::Gdk::Keysyms;
use Glib;
binmode(STDOUT, ":utf8");
binmode(STDERR, ":utf8");
eval { require Locale::gettext };

if ($@) {
    print "Gettext not available, english text only\n";

    sub gettext {
        return $@;
    }
} else {
    import Locale::gettext;
    textdomain('lyricue');

    # Hack to get this working under mandrake
    use lib qw(/usr/lib/libDrakX);
    eval { require c::stuff };
    if ($@) {
        bind_textdomain_codeset('lyricue', "UTF-8");
    } else {
        c::stuff::bind_textdomain_codeset('lyricue', "UTF-8");
    }
}

# convenience variables for true and false
use constant FALSE => 0;
use constant TRUE  => 1;

use constant NORMAL     => 0;
use constant SLIDE_TEXT => 1;
use constant WIPE       => 2;
use constant CLIP       => 3;

use constant NONE  => 0;
use constant UP    => 1;
use constant DOWN  => 2;
use constant RIGHT => 4;
use constant LEFT  => 8;
use constant WAIT  => 16;

#
# Site Configuration.  You should only have to
# edit this section.
#

my ($globals);
$globals->{'etcdir'}   = "/etc/lyricue/";
$globals->{'basedir'}  = $ENV{'HOME'} . "/.lyricue/";
$globals->{'sharedir'} = "/usr/share/lyricue/";

#
# You shouldn't have to change anything after this line
#

$globals->{'version'}     = "1.9.2";
$globals->{'accessfile'}  = $globals->{'etcdir'} . "access.conf";
$globals->{'defaultconf'} = $globals->{'etcdir'} . "default.conf";
$globals->{'configfile'}  = $globals->{'basedir'} . "config2";
$globals->{'gladefile'}   = $globals->{'sharedir'} . "lyricue.glade";
$globals->{'host'}        = "localhost";
$globals->{'lyricdb'}     = "lyricDb";
$globals->{'mediadb'}     = "mediaDb";
$globals->{'bibledb'}     = "";
$globals->{'biblename'}   = "";
$globals->{'usesword'}    = TRUE;
$globals->{'fast'}        = FALSE;
$globals->{'bg_file'}     = "/tmp/lyricue.bg";
$globals->{'use_port'}      = "2346";    #port used for lyric server socket
$globals->{'server_port'}   = "2346";    #port used for lyric server socket
$globals->{'preview_port'}  = "2347";    #port used for lyric server socket
$globals->{'miniview_port'} = "2348";    #port used for lyric server socket
$globals->{'diatheke'} = `which diatheke`;
chomp $globals->{'diatheke'};

eval { require Gnome2::Canvas; };
if ($@) {
    print "Optional module Gnome2::Canvas not available. Using simple server\n";
    $globals->{'fast'} = TRUE;
} else {
    import Gnome2::Canvas;
}
if ($globals->{'diatheke'} eq "") {
    $globals->{'diatheke'} = "true";
}

my $DEBUG           = FALSE;
my $exec_pid        = 0;
my $MINISERV        = -1;
my $MINISCALE       = 4;       # Default Scaling for the preview window
my $LOOPPARENT      = -1;      #Absolute parent for looping in sublists
my $current_list    = 1;
my $current_item    = 1;
my $preview_item    = 0;
my $current_point   = -1;
my $steps           = 20;
my $bgimage_changed = FALSE;
my $headerHeight    = 0;
my ($background);
my @points;

my ($errorcodes);
$errorcodes->{'lyricdbopen'} = Encode::decode(
    "utf-8",
    gettext(
"I'm sorry but I could not open the lyric database.\nPlease confirm that Lyricue is installed correctly and MySql is running"
    )
);
$errorcodes->{'bibledbopen'} = Encode::decode(
    "utf-8",
    gettext(
"I'm sorry but I could not open the bible database.\nPlease confirm that Lyricue is installed correctly and the current bible database exists.\nThe requested database was named "
    )
  ),
  $errorcodes->{'sqlprepare'} =
  Encode::decode("utf-8", gettext("Unable to prepare query.\nHas mysql died?"));
$errorcodes->{'sqlexecute'} =
  Encode::decode("utf-8", gettext("Unable to execute query.\nHas mysql died?"));
$errorcodes->{'socketopen'} = Encode::decode(
    "utf-8",
    gettext(
"Sorry, I was unable to listen on the network.\nPlease make sure I am not already running"
    )
);

#***

#****** lyricue_server/main_code
# NAME
#   main_code - main code section, not in subroutine
# SYNOPSIS
#   No output
# FUNCTION
#   Figure out where to go
# INPUTS
#   Commandline
# OUTPUT
#   Everything
# SOURCE
#

# Parse command line arguments
if ($ARGV[0]) {
    foreach (0 .. (@ARGV - 1)) {
        if ($ARGV[$_] eq "-v") {
            print "Lyricue Server version " . $globals->{'version'} . "\n";
            exit;
        } elsif ($ARGV[$_] eq "-f") {
            $globals->{'fast'} = 1;
        } elsif ($ARGV[$_] eq "-d") {
            $DEBUG = 1;
        } elsif ($ARGV[$_] eq "-m") {
            $MINISERV = $ARGV[$_ + 1];
            if (!$MINISERV =~ /\d+$/) {
                $MINISERV = 0;
            }
        } elsif ($ARGV[$_] eq "-p") {
            $globals->{'use_port'} = $ARGV[$_ + 1];
        } elsif ($ARGV[$_] =~ /^\d+$/) {
        } else {
            print "\nUsage: lyricue_server <-v> <-m> <-c> <-d>\n\n";
            print "\t-v: Prints Lyricue version information & exits\n";
            print "\t-m: Runs in miniserv mode (acts as a preview window)\n";
            print "\t-d: Prints debugging messages\n";
            exit;
        }
    } ## end foreach (0 .. (@ARGV - 1))
} ## end if ($ARGV[0])

# Read the config file
if (!-w $globals->{'configfile'}) {
    if (!-d $globals->{'basedir'}) {
        mkdir $globals->{'basedir'}, 0777;
    }
    system("cp " . $globals->{'defaultconf'} . " " . $globals->{'configfile'});
}
my $config = load_config();
if ($config->{'FastServer'} == 1) {
    $globals->{'fast'} = TRUE;
}

my ($contents, @preset);
if (!($config->{'Colour'})) {
    $config->{'Colour'} = "#ffffff";
}

my ($bibleDbh);
foreach (keys %$config) {
    if (/^Preset/) {
        my $num = $_;
        $num =~ s/^Preset//g;
        $preset[$num] = $config->{$_};
    } elsif (/^DefBible/) {
        my @tmp = split(/;/, $config->{$_}, 2);
        my @tmp2 = split(/:/, $tmp[0], 2);
        $globals->{'bibledb'} = $tmp2[0];
        change_to_db($globals->{'bibledb'}, $tmp2[1]);
    }
}

my $pid =
`ps -e -o pid,cmd | grep "Lyricue Server on port $globals->{'use_port'}" | grep -v "grep" |sed -e 's/^ *//g' | cut -f1 -d" " `;
chomp($pid);
if ($pid) {
    debug("Lyricue Server was already running on given port, killing");
    kill 9, $pid;
}

# Open lyricDB and mediaDB
my $lyricDbh =
  DBI->connect("DBI:mysql:$globals->{'lyricdb'}:$globals->{'host'}",
    "lyric", "")
  || display_fatal($errorcodes->{'lyricdbopen'}, $!);

my $mediaDbh =
  DBI->connect("DBI:mysql:$globals->{'mediadb'}:$globals->{'host'}",
    "lyric", "")
  || display_fatal($errorcodes->{'mediadbopen'}, $!);

# Create the window
debug("Creating window");
my ($window);
my ($headerText, $mainText, $footerText);
my ($headhigh,   $headwide, $canvas, $root, $mainTextShadow);

my ($pixmap, $textcol);

if ($MINISERV > 0) {
    $window = Gtk2::Plug->new($MINISERV);
} else {
    $window = new Gtk2::Window->new('toplevel');
}
$window->set_title("Lyric Server");

while (Gtk2->events_pending) {
    Gtk2->main_iteration;
}

if ($MINISERV >= 0) {
    $window->show();
    $window->realize();
    my $width  = $config->{'Width'};
    my $height = $config->{'Height'};
    my ($width2, $height2) = $window->get_size();
    $MINISCALE = $width / $width2;
    $width  /= $MINISCALE;
    $height /= $MINISCALE;

    debug("Running in MINISERV (preview window) mode");
    debug("W * H:" . $width . "*" . $height);
} else {
    $window->show();
    $window->fullscreen();
    my $bitmap = Gtk2::Gdk::Bitmap->create_from_data(undef, 0, 1, 1);
    my $cursor = Gtk2::Gdk::Cursor->new_from_pixmap(
        $bitmap, $bitmap,
        Gtk2::Gdk::Color->new(0, 0, 0),
        Gtk2::Gdk::Color->new(0, 0, 0),
        0, 0
    );
    $window->window->set_cursor($cursor);

    debug("Running in SERVER (normal) mode");
}

while (Gtk2->events_pending) {
    Gtk2->main_iteration;
}

my $aspect = $config->{'Width'} / $config->{'Height'};
my $geom   = Gtk2::Gdk::Geometry->new;
$geom->min_aspect($aspect);
$window->set_geometry_hints($window, $geom, 'GDK_HINT_ASPECT');
if ($globals->{'fast'}) {
    debug("Using fast server");
    my $vbox = Gtk2::VBox->new(FALSE, 0);
    $window->add($vbox);
    debug("Creating text areas");

    # Create the area for lyrics and set styles
    my $mainStyle   = new Gtk2::Style;
    my $headerStyle = new Gtk2::Style;
    my $footerStyle = new Gtk2::Style;
    $headerText = Gtk2::Label->new();
    $mainText   = Gtk2::Label->new();
    $footerText = Gtk2::Label->new();
    $headerText->set_line_wrap(TRUE);
    $headerText->set_size_request(
        $config->{'Width'} - ($config->{'OverscanH'} * 2), -1);
    $headerText->set_justify('center');
    $mainText->set_line_wrap(TRUE);
    $footerText->set_line_wrap(TRUE);
    $footerText->set_size_request(
        $config->{'Width'} - ($config->{'OverscanH'} * 2), -1);
    $footerText->set_justify('center');
    $vbox->pack_start($headerText, FALSE, FALSE, 0);

    if ($config->{'CentreY'}) {
        $vbox->pack_start($mainText, TRUE, TRUE, 0);
    } else {
        $vbox->pack_start($mainText, FALSE, TRUE, 0);
        my $fill = Gtk2::Label->new();
        $vbox->pack_start($fill, TRUE, TRUE, 0);
    }
    $vbox->pack_start($footerText, FALSE, FALSE, 0);
} else {
    debug("Using full server");
    $canvas = Gnome2::Canvas->new();
    $canvas->set_scroll_region(1, 1, $config->{'Width'}, $config->{'Height'});
    $canvas->set_center_scroll_region(TRUE);
    $canvas->set_pixels_per_unit(1 / $MINISCALE);

    $window->add($canvas);
    $root = $canvas->root;
    $canvas->show();

    # Find font sizes
    my $layout  = $window->create_pango_layout("lj");
    my $tmpdesc =
      Gtk2::Pango::FontDescription->from_string($config->{'Header'});
    $layout->set_font_description($tmpdesc);
    ($headhigh, $headwide) = $layout->get_pixel_size;

    debug("Creating text areas");

    # Create the area for lyrics and set styles
    # Song lyrics - Middle of screen
    $mainText = Gnome2::Canvas::Item->new(
        $root, 'Gnome2::Canvas::RichText',
        x                => 0,
        y                => 0,
        width            => 0,
        height           => 0,
        anchor           => 'GTK_ANCHOR_CENTER',
        'cursor-visible' => FALSE
    );
    my $buffer = $mainText->get_buffer();
    my $tag2   = $buffer->create_tag(
        "Main",              "font",
        $config->{'Main'},   "foreground",
        $config->{'Colour'}, "wrap-mode",
        "word",              "editable-set",
        TRUE,                "editable",
        FALSE
    );
    $buffer->apply_tag_by_name("Main", $buffer->get_bounds);
}

debug("Loading background");
change_backdrop($config->{'BGImage'});

# callback registration
$window->signal_connect("delete_event", \&CloseAppWindow);

$window->signal_connect("key_press_event", \&HandleKey);

# init the TCP mode
my ($socket);
my @cnx = ();
my $con = 0;
my ($name, $aliases, $proto) = getprotobyname('tcp');

if ($globals->{'use_port'} !~ /^\d+$/) {
    ($name, $aliases, $globals->{'use_port'}) =
      getservbyport($globals->{'use_port'}, 'tcp');
}

while (Gtk2->events_pending) {
    Gtk2->main_iteration;
}

# set window attributes and show it
debug("Showing window");
$window->show_all();
$window->signal_connect("configure_event", \&Configure_event);
Configure_event();

if (!$MINISERV && !$globals->{'fast'}) {
    $canvas->update_now();
}

debug("Done");

debug("Main program running");

my $sockaddr = 'S n a4 x8';
$socket = IO::Socket::INET->new(
    Listen    => SOMAXCONN,
    LocalPort => $globals->{'use_port'},
    Reuse     => 1,
    Proto     => 'tcp'
);
$socket or display_fatal($errorcodes->{'socketopen'}, $!);
$0 = "Lyricue Server on port " . $globals->{'use_port'};
my $h;
use IO::Select;
my $s = IO::Select->new($socket);
debug("Listening on " . $globals->{'use_port'});

# Gtk event loop
while (1) {
    my @ready = $s->can_read(1);
    foreach $h (@ready) {
        check_socket($socket);
    }
    while (Gtk2->events_pending) {
        Gtk2->main_iteration;
    }
}

# Should never get here
exit(0);

#***

#****f* lyricue_server/process_input
# NAME
#   process_input
# SYNOPSIS
#   process_input ()
# FUNCTION
#   Reads from the socket and processes whatever is there
# INPUTS
#   text from socket
# OUTPUT
#   Update lyric screen
# SOURCE
#
sub process_input {
    debug("\n\nBeginning transaction from socket");
    my ($input) = @_;
    my $status = "";

    debug("Received :" . $input);
    if ($input) {
        Encode::decode("utf-8", $input);
        chomp($input);
        my @line = split(/:/, $input);
        $_ = lc($line[0]);

        if (/^status$/) {
            $status = "Status,W:"
              . $config->{'Width'} . ",H:"
              . $config->{'Height'} . ",F:"
              . $config->{'Main'} . ",B:"
              . $globals->{'bibledb'};
        } elsif (/^reconfig$/) {
            $config = load_config();
            $status = "Configuration reloaded";
        } elsif (/^backdrop$/) {
            $config->{'BGImage'} = $line[1];
            change_backdrop($config->{'BGImage'});
            $status = "Backdrop changed to " . $config->{'BGImage'};
        } elsif (/^blank$/) {
            set_header("");
            set_maintext("", NONE, FALSE);
            set_footer("");
            $status = "Screen blanked";
        } elsif (/^change_to_db$/) {
            change_to_db($line[1], $line[2]);
            $status = "Bible changed to " . $globals->{'bibledb'};
        } elsif (/^next_point$/) {
            if ($current_point > -1 && scalar(@points) > $current_point + 1) {
                my $pointtext = "";
                $current_point++;

                #Add all points up and including to current point
                for (my $count = 1 ; $count <= $current_point ; $count++) {
                    $pointtext .= $points[$count];
                }

                #Now figure out how many \n's to add
                if (my @original = ((join "", @points) =~ /\n/g)) {
                    if (my @pt = $pointtext =~ /\n/g) {
                        for (
                            my $ns = 0 ;
                            $ns < scalar(@original) - scalar(@pt) ;
                            $ns++
                          )
                        {
                            $pointtext .= "\n";
                        }
                    }
                }

                $pointtext =~ s/<.*?>//g;
                set_maintext($pointtext, NONE, FALSE);
            } else {
                debug("Can not advance one point - no points waiting");
            }
        } elsif (/^preview$/) {
            $line[1] =~ s/#SEMI#/:/g;
            my @extras = split(/#BREAK#/, $line[1]);
            set_header($extras[0]);
            $line[2] =~ s/#BREAK#/\n/g;
            $line[2] =~ s/#SEMI#/:/g;
            $line[2] =~ s/<.*?>//g;
            set_maintext(Encode::decode("utf-8", $line[2]), NONE, TRUE);

            if ($extras[2]) {
                set_footer(
                    gettext("Written by ") . $extras[1] . " - " . $extras[2]);
            } else {
                if ($extras[1]) {
                    set_footer(gettext("Written by ") . $extras[1]);
                }
            }
        } elsif (/^loopparent$/) {
            $LOOPPARENT = $line[1];
            debug("Set loop parent to: " . $LOOPPARENT);
        } elsif (/^display$/ && $line[1] ne "") {

            #
            # Change it to lowercase
            $line[1] = lc($line[1]);

            # display new lyrics
            my $query =
              "SELECT * FROM playlist WHERE playorder=" . $current_item;
            debug($query);
            my $sth = $lyricDbh->prepare($query)
              || display_fatal($errorcodes->{'sqlprepare'}, $!);
            my $rv = $sth->execute
              || display_fatal($errorcodes->{'sqlexecute'}, $!);
            my $current_play = $sth->fetchrow_hashref();

            if ($line[1] eq "playlist") {
                debug("Changing playlist to " . $line[2]);
                $current_list = $line[2];
            } elsif ($line[1] eq "current") {

                # ignore and just display same page
            } elsif ($line[1] eq "next_page") {
                my $query =
                  "SELECT playlist FROM playlist WHERE playorder="
                  . $current_item;
                debug($query);
                my $sth = $lyricDbh->prepare($query)
                  || display_fatal($errorcodes->{'sqlprepare'}, $!);
                my $rv = $sth->execute
                  || display_fatal($errorcodes->{'sqlexecute'}, $!);
                my @row = $sth->fetchrow_array();
                $query =
                    "SELECT MIN(playorder) FROM playlist WHERE playlist="
                  . $row[0]
                  . " AND playorder>"
                  . $current_item
                  . " ORDER BY playorder";
                debug($query);
                $sth = $lyricDbh->prepare($query)
                  || display_fatal($errorcodes->{'sqlprepare'}, $!);
                $rv = $sth->execute
                  || display_fatal($errorcodes->{'sqlexecute'}, $!);
                my @row2 = $sth->fetchrow_array();

                if ($row2[0]) {

                    #End of this particular list (song/sublist) not reached
                    debug("Looping to next item in list\n");
                    $current_item = $row2[0];
                } else {

                    #End of this particular list (song/sublist) reached
                    if ($line[2] eq "loop") {
                        debug("Finding next item to display in loop\n");

                        if ($LOOPPARENT == -1) {
                            debug("Looping a song, back to page 1\n");
                            $query =
"SELECT MIN(playorder) FROM playlist WHERE playlist="
                              . $row[0];
                            debug($query);
                            $sth = $lyricDbh->prepare($query)
                              || display_fatal($errorcodes->{'sqlprepare'}, $!);
                            $rv = $sth->execute
                              || display_fatal($errorcodes->{'sqlexecute'}, $!);
                            my @row3 = $sth->fetchrow_array();
                            if ($row3[0]) {
                                $current_item = $row3[0];
                            }
                        } else {
                            debug("Looping a sublist...\n");

                           #Build a 'context map', by tracing the
                           #steps from the current level, to the top of the list
                            debug("Building the context map...\n");
                            my @contextmap;    #array of playorders
                            my $item    = $current_item;
                            my $plpoint = -2;

                            while ($plpoint != $LOOPPARENT) {
                                $query =
"SELECT playlist FROM playlist WHERE playorder="
                                  . $item;
                                debug("\t" . $query);
                                $sth = $lyricDbh->prepare($query)
                                  || display_fatal($errorcodes->{'sqlprepare'},
                                    $!);
                                $rv = $sth->execute
                                  || display_fatal($errorcodes->{'sqlexecute'},
                                    $!);
                                my @playlist = $sth->fetchrow_array();

                                #Add playlist id to contextmap
                                @contextmap = (@contextmap, $playlist[0]);

                                #Update playlist pointer so we can do
                                #the test for equality to LOOPPARENT
                                $plpoint = $playlist[0];

                                #Change item to this playlist's playorder
                                $query =
                                    "SELECT playorder FROM playlist WHERE data="
                                  . $playlist[0]
                                  . " and (type='sub' or type='play')";
                                debug("\t" . $query);
                                $sth = $lyricDbh->prepare($query)
                                  || display_fatal($errorcodes->{'sqlprepare'},
                                    $!);
                                $rv = $sth->execute
                                  || display_fatal($errorcodes->{'sqlexecute'},
                                    $!);
                                my @playorder = $sth->fetchrow_array();

                                $item = $playorder[0];
                                debug("....\n");
                            }
                            debug("Context map built!\n");

                            #Find the next item
                            my $lastpo   = $current_item;
                            my $nextitem = $current_item;

                            foreach (@contextmap) {

                                #Find next item in the current context map list
                                $query =
                                    "SELECT MIN(playorder) FROM playlist WHERE "
                                  . " playlist="
                                  . $_
                                  . " and playorder > "
                                  . $lastpo;
                                debug($query);
                                $sth = $lyricDbh->prepare($query)
                                  || display_fatal($errorcodes->{'sqlprepare'},
                                    $!);
                                $rv = $sth->execute
                                  || display_fatal($errorcodes->{'sqlexecute'},
                                    $!);
                                my @results = $sth->fetchrow_array();

                                if ($results[0]) {

                                    #Set nextitem and leave loop
                                    $nextitem = $results[0];
                                    last;
                                } else {

                                    #prepare for next iteration
                                    $query =
                                        "SELECT playorder FROM playlist WHERE "
                                      . " data="
                                      . $_
                                      . " and (type='sub'"
                                      . " or type='play')";

                                    debug("\t" . $query);
                                    $sth = $lyricDbh->prepare($query)
                                      || display_fatal(
                                        $errorcodes->{'sqlprepare'}, $!);
                                    $rv = $sth->execute
                                      || display_fatal(
                                        $errorcodes->{'sqlexecute'}, $!);
                                    my @poresult = $sth->fetchrow_array();

                                    $lastpo = $poresult[0];
                                }
                            }

                            if ($current_item != $nextitem) {
                                debug("Found next item to show\n");
                                $current_item = $nextitem;
                            } else {

                                #End of the road, go back to start!
                                debug("No more items, back to start\n");
                                $query =
                                    "SELECT MIN(playorder) FROM playlist WHERE "
                                  . " playlist="
                                  . $LOOPPARENT;
                                debug($query);
                                $sth = $lyricDbh->prepare($query)
                                  || display_fatal($errorcodes->{'sqlprepare'},
                                    $!);
                                $rv = $sth->execute
                                  || display_fatal($errorcodes->{'sqlexecute'},
                                    $!);
                                my @start = $sth->fetchrow_array();
                                $current_item = $start[0];
                            }
                        }
                    }
                }
            } elsif ($line[1] eq "prev_page") {
                my $query =
                  "SELECT playlist FROM playlist WHERE playorder="
                  . $current_item;
                debug($query);
                my $sth = $lyricDbh->prepare($query)
                  || display_fatal($errorcodes->{'sqlprepare'}, $!);
                my $rv = $sth->execute
                  || display_fatal($errorcodes->{'sqlexecute'}, $!);
                my @row = $sth->fetchrow_array();
                $query =
                    "SELECT MAX(playorder) FROM playlist WHERE playlist="
                  . $row[0]
                  . " AND playorder<"
                  . $current_item
                  . " ORDER BY playorder";
                debug($query);
                $sth = $lyricDbh->prepare($query)
                  || display_fatal($errorcodes->{'sqlprepare'}, $!);
                $rv = $sth->execute
                  || display_fatal($errorcodes->{'sqlexecute'}, $!);
                my @row2 = $sth->fetchrow_array();

                if ($row2[0]) {
                    $current_item = $row2[0];
                } else {
                    if ($line[2] eq "loop") {
                        $query =
                          "SELECT MAX(playorder) FROM playlist WHERE playlist="
                          . $row[0];
                        debug($query);
                        $sth = $lyricDbh->prepare($query)
                          || display_fatal($errorcodes->{'sqlprepare'}, $!);
                        $rv = $sth->execute
                          || display_fatal($errorcodes->{'sqlexecute'}, $!);
                        my @row2 = $sth->fetchrow_array();
                        if ($row2[0]) {
                            $current_item = $row2[0];
                        }
                    }
                }

            } elsif ($line[1] eq "next_song") {
                my $query =
"SELECT a.playorder,a.playlist FROM playlist AS a, playlist AS b WHERE a.data=b.playlist AND a.type=\"play\" AND b.playorder="
                  . $current_item;
                debug($query);
                my $sth = $lyricDbh->prepare($query)
                  || display_fatal($errorcodes->{'sqlprepare'}, $!);
                my $rv = $sth->execute
                  || display_fatal($errorcodes->{'sqlexecute'}, $!);
                my @row;
                if (@row = $sth->fetchrow_array()) {
                    $current_item = $row[0];
                    $current_list = $row[1];
                }

                $query =
                    "SELECT MIN(playorder) FROM playlist WHERE playorder > "
                  . $current_item
                  . " AND playlist="
                  . $current_list;
                debug($query);
                $sth = $lyricDbh->prepare($query)
                  || display_fatal($errorcodes->{'sqlprepare'}, $!);
                $rv = $sth->execute
                  || display_fatal($errorcodes->{'sqlexecute'}, $!);
                @row = $sth->fetchrow_array();

                if (defined $row[0]) {
                    $current_item = $row[0];
                }
            } elsif ($line[1] eq "prev_song") {
                my $query =
"SELECT a.playorder,a.playlist FROM playlist AS a, playlist AS b WHERE a.data=b.playlist AND a.type=\"play\" AND b.playorder="
                  . $current_item;
                debug($query);
                my $sth = $lyricDbh->prepare($query)
                  || display_fatal($errorcodes->{'sqlprepare'}, $!);
                my $rv = $sth->execute
                  || display_fatal($errorcodes->{'sqlexecute'}, $!);
                my @row;
                if (@row = $sth->fetchrow_array()) {
                    $current_item = $row[0];
                    $current_list = $row[1];
                }

                $query =
                    "SELECT MAX(playorder) FROM playlist WHERE playorder < "
                  . $current_item
                  . " AND playlist="
                  . $current_list;
                debug($query);
                $sth = $lyricDbh->prepare($query)
                  || display_fatal($errorcodes->{'sqlprepare'}, $!);
                $rv = $sth->execute
                  || display_fatal($errorcodes->{'sqlexecute'}, $!);
                @row = $sth->fetchrow_array();

                if (defined $row[0]) {
                    $current_item = $row[0];
                }
            } elsif ($line[1] eq "page") {
                my $query =
                  "SELECT playlist FROM playlist WHERE playorder="
                  . $current_item;
                debug($query);
                my $sth = $lyricDbh->prepare($query)
                  || display_fatal($errorcodes->{'sqlprepare'}, $!);
                my $rv = $sth->execute
                  || display_fatal($errorcodes->{'sqlexecute'}, $!);
                my @row = $sth->fetchrow_array();

                $query =
                    "SELECT playorder FROM playlist WHERE playlist="
                  . $row[0]
                  . " ORDER BY playorder";
                debug($query);
                $sth = $lyricDbh->prepare($query)
                  || display_fatal($errorcodes->{'sqlprepare'}, $!);
                $rv = $sth->execute
                  || display_fatal($errorcodes->{'sqlexecute'}, $!);
                my $count = 0;

                while (($count < $line[2]) && (@row = $sth->fetchrow_array())) {
                    $count++;
                }
                if (defined $row[0]) {
                    $current_item = $row[0];
                }

            } else {
                $current_item = $line[1];
                $preview_item = 0;
            }

            # load lyrics from DB

            if ($preview_item) {
                my $tmp = $current_item;
                $current_item = $preview_item;
                $preview_item = $tmp;
            }
            $query = "SELECT * FROM playlist WHERE playorder=" . $current_item;
            debug($query);
            $sth = $lyricDbh->prepare($query)
              || display_fatal($errorcodes->{'sqlprepare'}, $!);
            $rv = $sth->execute
              || display_fatal($errorcodes->{'sqlexecute'}, $!);

            #Check for associate image and, if present, apply it.
            my $imgquery =
              "SELECT imagename FROM associations WHERE playlist="
              . $current_item;
            my $imgsth = $lyricDbh->prepare($imgquery)
              || display_fatal($errorcodes->{'sqlprepare'}, $!);
            $imgsth->execute || display_fatal($errorcodes->{'sqlexecute'}, $!);

            #Reset background if an image was shown
            if ($bgimage_changed) {
                $bgimage_changed = FALSE;
                change_backdrop($config->{'BGImage'});
            }

            if (my $imgrow = $imgsth->fetchrow_hashref()) {
                change_backdrop($imgrow->{'imagename'});
            }

            if ($exec_pid > 0) {
                debug("Killing " . $exec_pid);
                system('kill ' . $exec_pid);
                system('kill -9 ' . $exec_pid);
                $exec_pid = 0;
            }

            if (my $row = $sth->fetchrow_hashref()) {
                if ($row->{'type'} eq "back") {
                    my $file = $row->{'data'};
                    $config->{'BGImage'} = $file;
                    change_backdrop($file);
                } elsif ($row->{'type'} eq "file") {
                    if (-r $row->{'data'}) {
                        my ($fileobj, @fileexts);

                        # Image
                        @fileexts = qw(jpg gif png);
                        for $fileobj (@fileexts) {
                            if ($row->{'data'} =~ /$fileobj/i) {
                                $bgimage_changed = TRUE;
                                set_footer("");
                                set_maintext("", NONE, FALSE);
                                set_header("");
                                change_backdrop($row->{'data'});
                            }
                        }

                        # Movie file
                        @fileexts = qw(avi mpg mov);
                        for $fileobj (@fileexts) {
                            if ($row->{'data'} =~ /$fileobj/i) {
                                $exec_pid = fork;
                                if ($exec_pid > 0) {

  #my $wid = `xwininfo -name "Lyric Server" |grep "Window id:" | cut -f4 -d" "`;
                                    my $command = "mplayer " . $row->{'data'};
                                    if ($MINISERV >= 0) {
                                        my ($x, $y, $wid, $high, $depth) =
                                          $window->window->get_geometry;
                                        ($x, $y) =
                                          $window->window->get_root_origin;
                                        $command .=
                                            " -ao null -nofs -geometry " . $wid
                                          . "x"
                                          . $high . "+"
                                          . $x . "+"
                                          . $y;
                                    } else {
                                        system($command);
                                        print $command. "\n";
                                    }

                         #system('mplayer ' . $row->{'data'} . ' -wid ' . $wid);
                                }
                            }
                        }
                    }
                } elsif ($row->{'type'} eq "imag") {
                    $bgimage_changed = TRUE;
                    set_footer("");
                    set_maintext("", NONE, FALSE);
                    set_header("");
                    change_backdrop($row->{'data'});
                } elsif ($row->{'type'} eq "vers") {

                    # Kill invalid points from previous songs
                    $current_point = -1;
                    @points        = ();

                    #Reset background if an image was shown
                    if ($bgimage_changed) {
                        $bgimage_changed = FALSE;
                        change_backdrop($config->{'BGImage'});
                    }

                    my $query =
"SELECT * FROM playlist,playlists WHERE playlist.playlist=playlists.id AND playorder="
                      . $current_item;
                    debug($query);
                    my $sth = $lyricDbh->prepare($query)
                      || display_fatal($errorcodes->{'sqlprepare'}, $!);
                    my $rv = $sth->execute
                      || display_fatal($errorcodes->{'sqlexecute'}, $!);

                    my $row        = $sth->fetchrow_hashref();
                    my $transition = $row->{'transition'};

                    my $versetext = $row->{'title'};
                    my @line      = split(/[:-]/, $row->{'title'});
                    my $verses    = $row->{'data'};
                    my $verse     = "";

                    ($line[2], $line[4]) = split(/-/, $row->{'data'});
                    if ($line[4] eq "") {
                        $line[4]=$line[2];
                    }
                    if (!$globals->{'usesword'}) {
                        $query = "SELECT book FROM verse WHERE book LIKE \"".$line[0]."%\"";
                        $sth = $bibleDbh->prepare($query)
                          || display_fatal($errorcodes->{'sqlprepare'}, $!);
                        $rv = $sth->execute
                          || display_fatal($errorcodes->{'sqlexecute'}, $!);
                        my @bookrow = $sth->fetchrow_array();
                        $line[0] = $bookrow[0];

                        if ($line[1] == $line[3]) {
                            $query =
                                "SELECT * FROM  verse WHERE book LIKE \""
                              . $line[0]
                              . "%\" AND chapternum="
                              . $line[1]
                              . " AND versenum>="
                              . $line[2]
                              . " AND versenum <= "
                              . $line[4];
                        } else {
                            $query =
                                "SELECT * FROM verse WHERE book LIKE \""
                              . $line[0]
                              . "%\" AND ((chapternum="
                              . $line[1]
                              . " AND versenum>="
                              . $line[2]
                              . ") OR (chapternum>"
                              . $line[1]
                              . " AND chapternum<"
                              . $line[3]
                              . ") OR (chapternum="
                              . $line[3]
                              . " AND versenum<="
                              . $line[4] . "))";
                        } ## end else
                        debug($query);
                        $sth = $bibleDbh->prepare($query)
                          || display_fatal($errorcodes->{'sqlprepare'}, $!);
                        $rv = $sth->execute
                          || display_fatal($errorcodes->{'sqlexecute'}, $!);

                        while ($row = $sth->fetchrow_hashref()) {
                            my $line =
                                $row->{'chapternum'} . ":"
                              . $row->{'versenum'} . "   "
                              . $row->{'verse'};
                            $verse .= $line . "\n";
                        }
                    } else {
                        my $command = "";
                        print "dia: " . $globals->{'diatheke'} . "\n";
                        $command = sprintf(
                            "%s -b %s -k '%s' %d:%d-%d:%d |tr \\\\n \' \'",
                            $globals->{'diatheke'}, $globals->{'bibledb'},
                            $line[0],               $line[1],
                            $line[2],               $line[3],
                            $line[4],               $line[0]
                        );
                        debug($command);
                        my @command_out =
                          split(/$line[0]/,
                            Encode::decode('utf-8', `$command`));

                        foreach (@command_out) {
                            chomp;
                            my $line2 = $_;
                            $line2 =~ s/^$line[0] //g;
                            if ($line2 ne "") {
                                $verse .= $line2 . "\n";
                            }
                        }
                    }

                    set_maintext($verse, $transition, TRUE);

                    set_header($versetext);
                    set_footer($globals->{'biblename'});
                    $status = "Displaying " . $versetext . " verses " . $verses;
                } elsif ($row->{'type'} eq "play" | $row->{'type'} eq "sub") {
                    my $query =
                        "SELECT * FROM playlist WHERE playlist="
                      . $row->{'data'}
                      . " ORDER BY playorder";
                    debug($query);
                    $sth = $lyricDbh->prepare($query)
                      || display_fatal($errorcodes->{'sqlprepare'}, $!);
                    my $rv = $sth->execute
                      || display_fatal($errorcodes->{'sqlexecute'}, $!);
                    my $row = $sth->fetchrow_hashref();
                    update_display("display", $row->{'playorder'}, 0);

                } else {
                    my $query2 =
"SELECT title,artist,lyrics,copyright,pagenum FROM lyricMain AS l, page AS pa WHERE pa.songid=l.id AND pa.pageid="
                      . $row->{'data'};
                    debug($query2);
                    my $sth2 = $lyricDbh->prepare($query2)
                      || display_fatal($errorcodes->{'sqlprepare'}, $!);
                    my $rv2 = $sth2->execute
                      || display_fatal($errorcodes->{'sqlexecute'}, $!);
                    my $row2 = $sth2->fetchrow_hashref();

                    $row2->{'lyrics'} =~ s/
/\n/g;
                    my $footer = "";
                    if ($row2->{'copyright'} =~ /^Preset/) {
                        $row2->{'copyright'} =~ s/^.*([0-9]).*$/$1/g;
                        $footer .= $preset[$row2->{'copyright'}];
                    } else {
                        $footer .= $row2->{'copyright'};
                    }
                    if ($row2->{'artist'} ne "") {
                        $footer =
                            gettext("Written by ")
                          . $row2->{'artist'} . " - "
                          . $footer;
                    }

                    # Determine if this is a multi-point page
                    if ($row2->{'lyrics'} =~ m/<UL>/) {
                        debug("This page has multiple points...");
                        $current_point = 1;
                        @points = split(/<LI>/, $row2->{'lyrics'});
                        my $pointtext = $points[$current_point];

                        #Now figure out how many \n's to add
                        if (my @o = ($row2->{'lyrics'} =~ /\n/g)) {
                            if (my @n = $pointtext =~ /\n/g) {
                                my $x;
                                for (
                                    $x = 0 ;
                                    $x < scalar(@o) - scalar(@n) ;
                                    $x++
                                  )
                                {
                                    $pointtext .= "\n";
                                }
                            }
                        }
                        $row2->{'lyrics'} = $pointtext;
                    } else {
                        $current_point = -1;
                        @points        = ();
                    }
                    set_header($row2->{'title'});
                    $row2->{'lyrics'} =~ s/<.*?>//g;
                    set_maintext($row2->{'lyrics'}, $row->{'transition'},
                        FALSE);
                    set_footer($footer);
                    $status =
                        "Displaying "
                      . $row2->{'title'}
                      . " page "
                      . $row2->{'pagenum'};
                } ## end else
                $window->show_all();
            } ## end if (my $row = $sth->fetchrow_hashref...
            if ($preview_item) {
                $current_item = $preview_item;
                $preview_item = 0;
            }
        } ## end elsif (/^display$/)
    } ## end if ($_)
    debug("The status message sent is: " . $status);
    return $status;
} ## end sub process_input
    #***

#****f* lyricue_server/CloseAppWindow
# NAME
#   CloseAppWindow
# SYNOPSIS
#   CloseAppWindow ()
# FUNCTION
#   Close the lyricue_server window
# INPUTS
#   None
# OUTPUT
#   None
# SOURCE
#
sub CloseAppWindow {
    debug("Exiting Child");
    if ($globals->{'fast'}) {
        unlink $globals->{'bg_file'};
    }
    $window->destroy;
    exit;
    return FALSE;
}

#***

#****f* lyricue_server/HandleKey
# NAME
#   HandleKey
# SYNOPSIS
#   HandleKey ( $widget, $data )
# FUNCTION
#   Parses keyboard input
# INPUTS
#   $widget - Calling widget
#   $data   - structure containing event
# OUTPUT
#   calls update_display to update screen
# SOURCE
#
sub HandleKey {
    my ($widget, $data) = @_;

    if (   ($data->keyval == $Gtk2::Gdk::Keysyms{Left})
        || ($data->keyval == $Gtk2::Gdk::Keysyms{KP_Left}))
    {
        update_display("display", "prev_page", $config->{'Loop'});
    } elsif (($data->keyval == $Gtk2::Gdk::Keysyms{Up})
        || ($data->keyval == $Gtk2::Gdk::Keysyms{KP_Up}))
    {
        update_display("display", "prev_song", 0);
    } elsif (($data->keyval == $Gtk2::Gdk::Keysyms{Right})
        || ($data->keyval == $Gtk2::Gdk::Keysyms{KP_Right}))
    {
        update_display("display", "next_page", $config->{'Loop'});
    } elsif (($data->keyval == $Gtk2::Gdk::Keysyms{Down})
        || ($data->keyval == $Gtk2::Gdk::Keysyms{KP_Down}))
    {
        update_display("display", "next_song", 0);
    } elsif (($data->keyval == $Gtk2::Gdk::Keysyms{KP_0})
        || ($data->keyval == $Gtk2::Gdk::Keysyms{KP_Insert}))
    {
        update_display("blank", 0, 0);
    } elsif ($data->keyval == $Gtk2::Gdk::Keysyms{Q}) {

        # exit
        my $dialog = Gtk2::Dialog->new(
            'Confirm Exit', undef, 'modal',
            'gtk-ok'     => 'ok',
            'gtk-cancel' => 'cancel',
        );
        $dialog->vbox->pack_start(
            Gtk2::Label->new(
                "Are you sure you want to close the Lyricue Server?"),
            TRUE, TRUE, 0
        );
        $dialog->show_all();
        my $response = $dialog->run;
        print("Response: " . $response . "\n");
        $dialog->destroy;
        if ($response eq "ok") {
            CloseAppWindow();
        }
    } else {
        debug("Unknown key: " . $data->keyval);
        return FALSE;
    }
    return TRUE;
} ## end sub HandleKey

#***

#****f* lyricue_server/change_backdrop
# NAME
#   change_backdrop
# SYNOPSIS
#   change_backdrop ( $type, $backdrop )
# FUNCTION
#   Loads an image and sets it as the screens background
# INPUTS
#   $id - id of image
# OUTPUT
#   Updates screen
# SOURCE
#
sub change_backdrop {
    my ($id) = @_;
    debug("Setting backdrop");
    my $query =
      "SELECT format, description, data FROM media WHERE id=\"" . $id . "\"";
    debug($query);
    my $sth = $mediaDbh->prepare($query)
      || display_fatal($errorcodes->{'sqlprepare'}, $!);
    my $rv = $sth->execute || display_fatal($errorcodes->{'sqlexecute'}, $!);
    my $row = $sth->fetchrow_hashref();
    if ($row) {

        if ($row->{'format'} eq "bg") {
            debug("Changing backdrop colour to " . $row->{'description'});
            if ($globals->{'fast'}) {
                open(BGIMG, ">" . $globals->{'bg_file'});
                print BGIMG
                  sprintf(
'/* XPM */\nstatic char *b[] = { "1 1 1 1", "  c %s", " " };\n',
                    $row->{'description'});
                close BGIMG;
            } else {
                if (defined $background) {
                    $background->destroy;
                }

                $background = Gnome2::Canvas::Item->new(
                    $root, 'Gnome2::Canvas::Rect',
                    x1          => 0,
                    y1          => 0,
                    x2          => $config->{'Width'},
                    y2          => $config->{'Height'},
                    fill_color  => $row->{'description'},
                    width_units => 0
                );
            }
        } else {
            debug("Changing backdrop image to " . $row->{'description'});
            my $pixbuf_loader = Gtk2::Gdk::PixbufLoader->new();
            $pixbuf_loader->set_size($config->{'Width'}, $config->{'Height'});
            eval { $pixbuf_loader->write($row->{'data'}); };
            eval { $pixbuf_loader->close() };
            if ($@) {
                debug("Unable to load background: $row->{'description'}");
            } else {
                my $pixbuf = $pixbuf_loader->get_pixbuf();
                if ($globals->{'fast'}) {
                    $pixbuf->save($globals->{'bg_file'}, 'png');
                } else {
                    if (defined $background) {
                        $background->destroy;
                    }
                    $background = Gnome2::Canvas::Item->new(
                        $root, 'Gnome2::Canvas::Pixbuf',
                        pixbuf     => $pixbuf,
                        x          => 1,
                        y          => 1,
                        width      => $config->{'Width'},
                        height     => $config->{'Height'},
                        width_set  => TRUE,
                        height_set => TRUE,
                    );
                }
            }
        }
        if ($globals->{'fast'}) {
            my $rc_style = Gtk2::RcStyle->new;
            $rc_style->bg_pixmap_name('normal', $globals->{'bg_file'});
            $window->modify_style($rc_style);
        } else {
            $background->lower_to_bottom;
        }
    }
} ## end sub change_backdrop

#***

#****f* lyricue_server/update_display
# NAME
#   update_display
# SYNOPSIS
#   update_display ( $command, $primary, $secondary, $tertiary)
# FUNCTION
#   Prints text to FIFO in predetermined format
# INPUTS
#   $command   - Main command to send
#   $primary   - Primary parameter to command
#   $secondary - Secondary parameter to send
#   $tertiary  - Tertiary parameter to send
# OUTPUT
#   Sends it all to the socket
# SOURCE
#
sub update_display {
    my ($command, $primary, $secondary) = @_;

    if (
        my $server = IO::Socket::INET->new(
            Proto    => "tcp",
            PeerAddr => "localhost",
            PeerPort => $globals->{'use_port'}
        )
      )
    {
        print $server $command . ":" . $primary . ":" . $secondary . "\n";
        close($server);
    }
} ## end sub update_display

sub update_miniview {
    my ($command) = @_;

    if (
        my $server = IO::Socket::INET->new(
            Proto    => "tcp",
            PeerAddr => "localhost",
            PeerPort => $globals->{'miniview_port'}
        )
      )
    {
        print $server $command;
        close($server);
    }
} ## end sub update_miniview

#***

#****f* lyricue_server/debug
# NAME
#   debug
# SYNOPSIS
#   debug ( $text )
# FUNCTION
#   Checks if $DEBUG is set and if so outputs text to STDERR
# INPUTS
#   $text - text to output
# OUTPUT
#   $text to STDERR
# SOURCE
#
sub debug {
    if ($DEBUG) {
        my $text = shift;
        chomp($text);
        print STDERR $text . "\n";
    }
} ## end sub debug

#***

#****f* lyricue_server/change_to_db
# NAME
#   change_to_db
# SYNOPSIS
#   change_to_db ( $db )
# FUNCTION
#   Disconnects old bible database and loads a new one
# INPUTS
#   $text - text to output
# OUTPUT
#   No visible output except outputs to STDERR via debug
# SOURCE
#
sub change_to_db {
    my ($db, $type) = @_;
    $globals->{'bibledb'} = $db;
    if (!$globals->{'usesword'}) {
        $bibleDbh->disconnect;
    }
    if ($type eq "db") {
        $bibleDbh =
          DBI->connect("DBI:mysql:$db:$globals->{'host'}", "lyric", "")
          || display_fatal($errorcodes->{'bibledbopen'} . $globals->{'bibledb'},
            $!);
        $globals->{'usesword'} = FALSE;
    } else {
        $globals->{'usesword'} = TRUE;
        $bibleDbh="";
    }
    $globals->{'biblename'} = $config->{'Bibles'}->{$globals->{'bibledb'}};
    $globals->{'biblename'} =~ s/^.*?://g;
    $globals->{'biblename'} =~ s/^.*?;//g;
    $globals->{'biblename'} =~ s/_//g;
} ## end sub debug

#****f* lyricue_server/check_socket
# NAME
#   check_socket
# SYNOPSIS
#   check_socket ($socket, $condition, $flags)
# FUNCTION
#   Check the socket for new data and handle it
# INPUTS
#   $socket - Socket to listen to
#   $condition - flags if something is on socket
#   $flags - Flags describing socket
# OUTPUT
#   No visible output except outputs to STDERR via debug
# SOURCE
#
sub check_socket {
    my ($socket, $condition, $flags) = @_;
    my $new_sock = $socket->accept();
    while (defined($_ = <$new_sock>)) {
        my $value = $_;
        my $stat  = process_input($value);
        chomp($stat);
        print $new_sock $stat . "\n";

        # Forward onto miniserver (if not the miniserver)
        if ($globals->{'use_port'} == $globals->{'server_port'}) {
            update_miniview($value);
        }
    }
    close($new_sock);

    return TRUE;
}

#***

sub load_config {
    my ($conf);
    debug("Loading Preferences from " . $globals->{'configfile'});
    my $bibleCount = 0;
    my $appCount   = 0;
    open(CONFIG, $globals->{'configfile'})
      || display_fatal("Couldn't open config file", $!);
    $conf->{'Width'}  = 0;
    $conf->{'Height'} = 0;
    while (<CONFIG>) {
        chomp;
        my @line = split(/=/);
        $line[0] =~ s/ *$//g;
        $line[1] =~ s/ *$//g;
        if (!$line[1]) {
            $line[1] = "";
        }
        $line[1] =~ s/^ *//g;
        if ($line[0] eq "App") {
            $conf->{'App'}[$appCount++] = $line[1];
        } else {
            $conf->{$line[0]} = $line[1];
        }
    }
    $conf->{'AppCount'} = $appCount;
    $conf->{'Bibles'}   = get_bibles();
    return $conf;
}

sub set_maintext {
    my ($text, $transition, $wrap) = @_;
    debug("Set maintext");
    my ($oldText);
    if (!defined $text) { $text = ""; }
    if ($globals->{'fast'}) {
        my $font_desc =
          Gtk2::Pango::FontDescription->from_string($config->{'Main'});
        my $colour = Gtk2::Gdk::Color->parse($config->{'Colour'});
        $mainText->modify_fg('normal', $colour);
        $mainText->modify_font($font_desc);
        $mainText->set_text($text);
        $mainText->set_line_wrap($wrap);
        if ($wrap) {
            $mainText->set_size_request(
                $config->{'Width'} - ($config->{'OverscanH'} * 2), -1);
        }
    } else {
        if (!defined $transition) { $transition = 0; }

        # Set the transition values
        my $old_direction = mod($transition, 32);
        $transition = $transition >> 5;
        my $new_direction = mod($transition, 32);
        my $effect        = $transition >> 5;

        # Copy the old mainText to oldText
        $oldText = $mainText;

        my $top_y = ($config->{'Height'} - $config->{'ShadowSize'}) / 2;
        if (defined $config->{'CenterY'} && $config->{'CentreY'} eq "") {
            $top_y = $headerHeight;
        }

        # Create a new mainText;
        $mainText = Gnome2::Canvas::Item->new(
            $root, 'Gnome2::Canvas::RichText',
            x      => ($config->{'Width'} - $config->{'ShadowSize'}) / 2,
            y      => $top_y,
            anchor => 'GTK_ANCHOR_CENTER',
            width  => $config->{'Width'} - ($config->{'OverscanH'} * 2) -
              $config->{'ShadowSize'},
            height => $config->{'Height'} - $headhigh -
              ($config->{'OverscanV'} * 2) - $config->{'ShadowSize'},
            'cursor-visible' => FALSE
        );
        $mainText->show();
        my $buffer = $mainText->get_buffer();
        my $tag    = $buffer->create_tag(
            "Main",              "font",
            $config->{'Main'},   "foreground",
            $config->{'Colour'}, "wrap-mode",
            "word",              "editable-set",
            TRUE,                "editable",
            FALSE
        );
        $buffer->apply_tag_by_name("Main", $buffer->get_bounds);

        # Hide the shadow during the transition
        if ($mainTextShadow) { $mainTextShadow->hide(); }
        my $widget = Gtk2::Label->new();
        my $layout = $widget->create_pango_layout("");
        $layout->set_wrap('word');
        $layout->set_width(
            (
                $config->{'Width'} - ($config->{'OverscanH'} * 2) -
                  $config->{'ShadowSize'}
            ) * PANGO_SCALE
        );
        my $desc = Gtk2::Pango::FontDescription->from_string($config->{'Main'});

        # Find old/new dimensions
        $layout->set_font_description($desc);
        $layout->set_text($oldText->get_buffer()
              ->get_text($oldText->get_buffer()->get_bounds, FALSE));
        my ($ow, $oh) = $layout->get_pixel_size;
        $ow = $ow + 10;
        $oh = $oh + 10;
        $layout->set_text($text);
        my ($w, $h) = $layout->get_pixel_size;
        $w = $w + 10;
        $h = $h + 10;
        my $centreX = $config->{'Width'} / 2;
        my $centreY = $config->{'Height'} / 2;

        if (defined $config->{'CentreY'} && $config->{'CentreY'} == 0) {
            $centreY = ($h / 2) + $headerHeight;
        }

        my @items = ();
        if ($effect == SLIDE_TEXT) {
            my $ostepx = 0;
            my $ostepy = 0;
            my $nstepx = 0;
            my $nstepy = 0;
            my $nx     = $centreX;
            my $ny     = $centreY;
            if ($oldText->get_buffer()
                ->get_text($oldText->get_buffer()->get_bounds, FALSE) eq "")
            {
                $old_direction = WAIT;
            }
            if ($old_direction & RIGHT) {
                $ostepx =
                  (($config->{'Width'} + ($ow / 2)) - $centreX) / $steps;
            }
            if ($old_direction & LEFT) {
                $ostepx =
                  -(($config->{'Width'} + ($ow / 2)) - $centreX) / $steps;
            }
            if ($old_direction & UP) {
                $ostepy =
                  (($config->{'Height'} + ($oh / 2)) - $centreY) / $steps;
            }
            if ($old_direction & DOWN) {
                $ostepy =
                  -(($config->{'Height'} + ($oh / 2)) - $centreY) / $steps;
            }
            if ($new_direction & RIGHT) {
                $nx = -($w / 2);
                $nstepx = (($config->{'Width'} + ($w / 2)) - $centreX) / $steps;
            }
            if ($new_direction & LEFT) {
                $nx = $config->{'Width'} + ($w / 2);
                $nstepx =
                  -(($config->{'Width'} + ($w / 2)) - $centreX) / $steps;
            }
            if ($new_direction & UP) {
                $ny = $config->{'Height'} + ($h / 2);
                $nstepy =
                  -(($config->{'Height'} + ($h / 2)) - $centreY) / $steps;
            }
            if ($new_direction & DOWN) {
                $ny     = -($h / 2);
                $nstepy =
                  (($config->{'Height'} + ($h / 2)) - $centreY) / $steps;
            }
            my $ox = $centreX;
            my $oy = $centreY;
            $buffer->set_text($text);
            $buffer->apply_tag_by_name("Main", $buffer->get_bounds);
            $mainText->set(width => $w, height => $h);
            $mainText->set(x => $nx, y => $ny);
            $mainText->set_buffer($buffer);

            if (!(($old_direction & WAIT) && ($new_direction & WAIT))) {
                foreach my $step (1 .. $steps) {
                    if (!($old_direction & WAIT)) {
                        $oldText->set(x => ($ox + ($step * $ostepx)));
                        $oldText->set(y => ($oy + ($step * $ostepy)));
                    }
                    if (!($new_direction & WAIT)) {
                        $mainText->set(x => ($nx + ($step * $nstepx)));
                        $mainText->set(y => ($ny + ($step * $nstepy)));
                    }
                    select(undef, undef, undef, 0.01);
                    while (Gtk2->events_pending) {
                        Gtk2->main_iteration;
                    }
                }
            }
            if (($old_direction & WAIT) || ($new_direction & WAIT)) {
                foreach my $step (1 .. $steps) {
                    if ($old_direction & WAIT) {
                        $oldText->set(x => ($ox + ($step * $ostepx)));
                        $oldText->set(y => ($oy + ($step * $ostepy)));
                    }
                    if ($new_direction & WAIT) {
                        $mainText->set(x => ($nx + ($step * $nstepx)));
                        $mainText->set(y => ($ny + ($step * $nstepy)));
                    }
                    select(undef, undef, undef, 0.01);
                    while (Gtk2->events_pending) {
                        Gtk2->main_iteration;
                    }
                }
            }
        } elsif ($effect == WIPE) {
            $items[0] = Gnome2::Canvas::Item->new(
                $root,
                'Gnome2::Canvas::Rect',
                y1         => ($config->{'Height'} - $oh) / 2,
                y2         => ($config->{'Height'} + $oh) / 2,
                x1         => ($config->{'Width'} - $ow) / 2,
                x2         => ($config->{'Width'} - $ow) / 2,
                fill_color => 'black'
            );
            my $stepsize = $ow / 20;
            for (
                my $fx = ($config->{'Width'} - $ow) / 2 ;
                $fx < ($config->{'Width'} + $ow) / 2 ;
                $fx = $fx + $stepsize
              )
            {
                $items[0]->set(x2 => $fx);
                select(undef, undef, undef, 0.01);
                while (Gtk2->events_pending) {
                    Gtk2->main_iteration;
                }
            }
            $buffer->set_text($text);
            $buffer->apply_tag_by_name("Main", $buffer->get_bounds);
            $mainText->set(width => $w, height => $h);
            $mainText->set_buffer($buffer);
            $items[0]->set(
                y1 => ($config->{'Height'} - $h) / 2,
                x1 => ($config->{'Width'} - $w) / 2,
                x2 => ($config->{'Width'} + $w) / 2,
                y2 => ($config->{'Height'} + $h) / 2
            );
            $stepsize = $w / 20;
            for (
                my $fx = ($config->{'Width'} - $w) / 2 ;
                $fx < ($config->{'Width'} + $w) / 2 ;
                $fx = $fx + $stepsize
              )
            {
                $items[0]->set(x1 => $fx);
                select(undef, undef, undef, 0.01);
                while (Gtk2->events_pending) {
                    Gtk2->main_iteration;
                }
            }
            $items[0]->destroy;
        } else {
            $buffer->set_text($text);
            $buffer->apply_tag_by_name("Main", $buffer->get_bounds);
            $mainText->set(width => $w, height => $h);
            $mainText->set(x => $centreX - ($config->{'ShadowSize'} / 2));
            $mainText->set(y => $centreY - ($config->{'ShadowSize'} / 2));
            $mainText->set_buffer($buffer);
        }
        $oldText->destroy;

        # Make sure text in right spot
        $buffer->set_text($text);
        $buffer->apply_tag_by_name("Main", $buffer->get_bounds);
        $mainText->set(
            x => $centreX - ($config->{'ShadowSize'} / 2),
            y => $centreY - ($config->{'ShadowSize'} / 2),
            width  => $w,
            height => $h,
        );
        $mainText->set_buffer($buffer);
        $mainText->show();

        if (!$MINISERV) {
            # Add the shadow
            $mainTextShadow = Gnome2::Canvas::Item->new(
                $root, 'Gnome2::Canvas::RichText',
                x => $centreX + ($config->{'ShadowSize'} / 2),
                y => $centreY + ($config->{'ShadowSize'} / 2),
                width            => $w,
                height           => $h,
                anchor           => 'GTK_ANCHOR_CENTER',
                'cursor-visible' => FALSE
            );
            my $buffer2 = $mainTextShadow->get_buffer();
            my $tags    = $buffer2->create_tag(
                "MainShadow",              "font",
                $config->{'Main'},         "foreground",
                $config->{'ShadowColour'}, "wrap-mode",
                "word",                    "editable-set",
                TRUE,                      "editable",
                FALSE
            );
            $buffer2->set_text($text);
            $buffer2->apply_tag_by_name("MainShadow", $buffer2->get_bounds);
            $mainTextShadow->set_buffer($buffer2);
            $mainText->raise_to_top();
            $mainTextShadow->show();
        }
    }
}

sub Configure_event {
    my ($width, $height) = $window->get_size();
    $MINISCALE = $config->{'Width'} / $width;
    if (!$globals->{'fast'}) {
        if ($canvas) {
            $canvas->set_pixels_per_unit(1 / $MINISCALE);
        }
    }
    $window->set_size_request($width, $config->{'Height'} / $MINISCALE);

    #debug($width . "x" . ($config->{'Height'} / $MINISCALE));
    #debug("Scale: " . $MINISCALE);
}

sub display_fatal {
    my ($message, $error) = @_;
    print STDERR "\n\n-------------\n";
    print STDERR "FATAL ERROR!!\n";
    print STDERR "-------------\n";
    print STDERR "Error description\n";
    print STDERR $message . "\n";
    print STDERR "------------------\n";
    # Don't want this to show up on projector
    #my $errorxml =
    #  Gtk2::GladeXML->new($globals->{'gladefile'}, 'dialogError', 'lyricue');
    #$errorxml->signal_autoconnect_from_package('');
    #$errorxml->get_widget('labelError')->set_text($message);
    #my $confirm = $errorxml->get_widget('dialogError')->run();
    #close_dialog($errorxml->get_widget('dialogError'));
    print STDERR "Full error message\n";
    print STDERR "------------------\n";
    die($error);
}

sub close_dialog {
    my ($widget) = @_;
    debug("Close dialog");
    $widget->get_toplevel->destroy;
}

sub mod {
    my ($inp, $div) = @_;
    my $rem = (($inp / $div) - (int($inp / $div))) * $div;
    return $rem;
}

sub set_footer {
    my ($text) = @_;
    if (!defined $text) { $text = ""; }
    if ($globals->{'fast'}) {
        my $font_desc =
          Gtk2::Pango::FontDescription->from_string($config->{'Footer'});
        $footerText->modify_font($font_desc);
        my $colour = Gtk2::Gdk::Color->parse($config->{'Colour'});
        $footerText->modify_fg('normal', $colour);
        $footerText->set_text($text);
    } else {
        my $widget = Gtk2::Label->new();
        my $layout = $widget->create_pango_layout("");
        $layout->set_wrap('word');
        $layout->set_width(
            (
                $config->{'Width'} - ($config->{'OverscanH'} * 2) -
                  $config->{'ShadowSize'}
            ) * PANGO_SCALE
        );
        my $desc =
          Gtk2::Pango::FontDescription->from_string($config->{'Footer'});
        $layout->set_font_description($desc);
        $layout->set_text($text);
        my ($w, $h) = $layout->get_pixel_size;
        $w = $w + 10;
        $h = $h + 10;
        if ($footerText) { $footerText->destroy(); }
        $footerText = Gnome2::Canvas::Item->new(
            $root, 'Gnome2::Canvas::RichText',
            x                => $config->{'Width'} / 2,
            y                => $config->{'Height'} - $config->{'OverscanV'},
            anchor           => 'GTK_ANCHOR_S',
            width            => $w,
            height           => $h,
            'cursor-visible' => FALSE
        );
        my $buffer = $footerText->get_buffer();
        my $tag3   = $buffer->create_tag(
            "Footer",            "font",
            $config->{'Footer'}, "foreground",
            $config->{'Colour'}, "wrap-mode",
            "word",              "editable-set",
            TRUE,                "editable",
            FALSE
        );
        $buffer->set_text($text);
        $buffer->apply_tag_by_name("Footer", $buffer->get_bounds);
    }
}

sub set_header {
    my ($text) = @_;
    if (!defined $text) { $text = ""; }
    if ($globals->{'fast'}) {
        my $font_desc =
          Gtk2::Pango::FontDescription->from_string($config->{'Footer'});
        $headerText->modify_font($font_desc);
        my $colour = Gtk2::Gdk::Color->parse($config->{'Colour'});
        $headerText->modify_fg('normal', $colour);
        $headerText->set_text($text);
    } else {

        my $widget = Gtk2::Label->new();
        my $layout = $widget->create_pango_layout("");
        $layout->set_wrap('word');
        $layout->set_width(
            (
                $config->{'Width'} - ($config->{'OverscanH'} * 2) -
                  $config->{'ShadowSize'}
            ) * PANGO_SCALE
        );
        my $desc =
          Gtk2::Pango::FontDescription->from_string($config->{'Footer'});
        $layout->set_font_description($desc);
        $layout->set_text($text);
        my ($w, $h) = $layout->get_pixel_size;
        $w            = $w + 10;
        $h            = $h + 10;
        $headerHeight = $h;
        if ($headerText) { $headerText->destroy(); }
        $headerText = Gnome2::Canvas::Item->new(
            $root, 'Gnome2::Canvas::RichText',
            x                => $config->{'Width'} / 2,
            y                => $config->{'OverscanV'},
            anchor           => 'GTK_ANCHOR_N',
            width            => $w,
            height           => $h,
            'cursor-visible' => FALSE
        );
        my $buffer = $headerText->get_buffer();
        my $tag3   = $buffer->create_tag(
            "Header",            "font",
            $config->{'Header'}, "foreground",
            $config->{'Colour'}, "wrap-mode",
            "word",              "editable-set",
            TRUE,                "editable",
            FALSE
        );
        $buffer->set_text($text);
        $buffer->apply_tag_by_name("Header", $buffer->get_bounds);
    }
}

sub get_bibles {
    my $bibles;
    open(CONFIG, $globals->{'configfile'})
      || display_fatal($errorcodes->{'fileopenread'} . $globals->{'configfile'},
        $!);
    while (<CONFIG>) {
        chomp;
        my @line = split(/=/);
        $line[0] =~ s/ *$//g;
        $line[1] =~ s/ *$//g;
        $line[1] =~ s/^ *//g;
        my @line2 = split(/;/, $line[1], 2);
        if ($line[0] eq "Bible") {
            $bibles->{$line2[1]} = "db;" . $line2[0];
        }
    }
    open(SWORD, $globals->{'diatheke'} . " -b system -k modulelist|");
    while (<SWORD>) {
        if (/^Biblical Texts:/) {
            while (<SWORD>) {
                if (/^Commentaries:/) {
                    while (<SWORD>) { }
                } else {
                    chomp;
                    my @bible = split(/:/, $_, 2);
                    $bible[0] =~ s/\s+$//;
                    $bible[1] =~ s/^\s+//;
                    $bibles->{$bible[0]} = "sword;" . $bible[1];
                }
            }
        }
    }
    close SWORD;
    return $bibles;
}
